/*
===========================================================================

HLML
v2.2.0

MIT License:

Copyright (c) 2019 Dan Moody (daniel.guy.moody@gmail.com).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"
#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"
#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"
#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"
#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool2x2& lhs, const bool2x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool2x2& lhs, const bool2x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<=( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>=( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 operator+( const bool2x2& lhs, const bool32_t rhs )
{
	return bool2x2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool2x2 operator+=( bool2x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x2 operator+( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool2x2 operator+=( bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 operator-( const bool2x2& lhs, const bool32_t rhs )
{
	return bool2x2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool2x2 operator-=( bool2x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x2 operator-( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool2x2 operator-=( bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 operator*( const bool2x2& lhs, const bool32_t rhs )
{
	return bool2x2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool2x2 operator*=( bool2x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x2 operator*( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool2x2 operator*=( bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x2 operator/( const bool2x2& lhs, const bool32_t rhs )
{
	return bool2x2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool2x2 operator/=( bool2x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x2 operator/( const bool2x2& lhs, const bool2x2& rhs )
{
	return bool2x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool2x2 operator/=( bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool2x2 operator++( bool2x2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x2 operator++( bool2x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool2x2 operator--( bool2x2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x2 operator--( bool2x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool2x2* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool2x2* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x2 transpose( const bool2x2& mat )
{
	return HLML_CONSTRUCT( bool2x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

// bool2x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool2x3& lhs, const bool2x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool2x3& lhs, const bool2x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<=( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>=( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 operator+( const bool2x3& lhs, const bool32_t rhs )
{
	return bool2x3(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool2x3 operator+=( bool2x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x3 operator+( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool2x3 operator+=( bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 operator-( const bool2x3& lhs, const bool32_t rhs )
{
	return bool2x3(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool2x3 operator-=( bool2x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x3 operator-( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool2x3 operator-=( bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 operator*( const bool2x3& lhs, const bool32_t rhs )
{
	return bool2x3(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool2x3 operator*=( bool2x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x3 operator*( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool2x3 operator*=( bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x3 operator/( const bool2x3& lhs, const bool32_t rhs )
{
	return bool2x3(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool2x3 operator/=( bool2x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x3 operator/( const bool2x3& lhs, const bool2x3& rhs )
{
	return bool2x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool2x3 operator/=( bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool2x3 operator++( bool2x3& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x3 operator++( bool2x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool2x3 operator--( bool2x3& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x3 operator--( bool2x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool2x3* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool2x3* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x2 transpose( const bool2x3& mat )
{
	return HLML_CONSTRUCT( bool3x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

// bool2x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool2x4& lhs, const bool2x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool2x4& lhs, const bool2x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<=( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>=( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 operator+( const bool2x4& lhs, const bool32_t rhs )
{
	return bool2x4(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool2x4 operator+=( bool2x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool2x4 operator+( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool2x4 operator+=( bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 operator-( const bool2x4& lhs, const bool32_t rhs )
{
	return bool2x4(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool2x4 operator-=( bool2x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool2x4 operator-( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool2x4 operator-=( bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 operator*( const bool2x4& lhs, const bool32_t rhs )
{
	return bool2x4(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool2x4 operator*=( bool2x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool2x4 operator*( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool2x4 operator*=( bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool2x4 operator/( const bool2x4& lhs, const bool32_t rhs )
{
	return bool2x4(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool2x4 operator/=( bool2x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool2x4 operator/( const bool2x4& lhs, const bool2x4& rhs )
{
	return bool2x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool2x4 operator/=( bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool2x4 operator++( bool2x4& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x4 operator++( bool2x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool2x4 operator--( bool2x4& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool2x4 operator--( bool2x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool2x4* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool2x4* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x2 transpose( const bool2x4& mat )
{
	return HLML_CONSTRUCT( bool4x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

// bool3x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool3x2& lhs, const bool3x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool3x2& lhs, const bool3x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<=( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>=( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 operator+( const bool3x2& lhs, const bool32_t rhs )
{
	return bool3x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool3x2 operator+=( bool3x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x2 operator+( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool3x2 operator+=( bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 operator-( const bool3x2& lhs, const bool32_t rhs )
{
	return bool3x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool3x2 operator-=( bool3x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x2 operator-( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool3x2 operator-=( bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 operator*( const bool3x2& lhs, const bool32_t rhs )
{
	return bool3x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool3x2 operator*=( bool3x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x2 operator*( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool3x2 operator*=( bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x2 operator/( const bool3x2& lhs, const bool32_t rhs )
{
	return bool3x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool3x2 operator/=( bool3x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x2 operator/( const bool3x2& lhs, const bool3x2& rhs )
{
	return bool3x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool3x2 operator/=( bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool3x2 operator++( bool3x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x2 operator++( bool3x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool3x2 operator--( bool3x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x2 operator--( bool3x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool3x2* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool3x2* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat.rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x3 transpose( const bool3x2& mat )
{
	return HLML_CONSTRUCT( bool2x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

// bool3x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool3x3& lhs, const bool3x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool3x3& lhs, const bool3x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<=( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>=( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 operator+( const bool3x3& lhs, const bool32_t rhs )
{
	return bool3x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool3x3 operator+=( bool3x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x3 operator+( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool3x3 operator+=( bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 operator-( const bool3x3& lhs, const bool32_t rhs )
{
	return bool3x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool3x3 operator-=( bool3x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x3 operator-( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool3x3 operator-=( bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 operator*( const bool3x3& lhs, const bool32_t rhs )
{
	return bool3x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool3x3 operator*=( bool3x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x3 operator*( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool3x3 operator*=( bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x3 operator/( const bool3x3& lhs, const bool32_t rhs )
{
	return bool3x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool3x3 operator/=( bool3x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x3 operator/( const bool3x3& lhs, const bool3x3& rhs )
{
	return bool3x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool3x3 operator/=( bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool3x3 operator++( bool3x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x3 operator++( bool3x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool3x3 operator--( bool3x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x3 operator--( bool3x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool3x3* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool3x3* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat.rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x3 transpose( const bool3x3& mat )
{
	return HLML_CONSTRUCT( bool3x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

// bool3x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool3x4& lhs, const bool3x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool3x4& lhs, const bool3x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<=( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>=( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 operator+( const bool3x4& lhs, const bool32_t rhs )
{
	return bool3x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool3x4 operator+=( bool3x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool3x4 operator+( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool3x4 operator+=( bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 operator-( const bool3x4& lhs, const bool32_t rhs )
{
	return bool3x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool3x4 operator-=( bool3x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool3x4 operator-( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool3x4 operator-=( bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 operator*( const bool3x4& lhs, const bool32_t rhs )
{
	return bool3x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool3x4 operator*=( bool3x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool3x4 operator*( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool3x4 operator*=( bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool3x4 operator/( const bool3x4& lhs, const bool32_t rhs )
{
	return bool3x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool3x4 operator/=( bool3x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool3x4 operator/( const bool3x4& lhs, const bool3x4& rhs )
{
	return bool3x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool3x4 operator/=( bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool3x4 operator++( bool3x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x4 operator++( bool3x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool3x4 operator--( bool3x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool3x4 operator--( bool3x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool3x4* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool3x4* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat.rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x3 transpose( const bool3x4& mat )
{
	return HLML_CONSTRUCT( bool4x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

// bool4x2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool4x2& lhs, const bool4x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool4x2& lhs, const bool4x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<=( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>=( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 operator+( const bool4x2& lhs, const bool32_t rhs )
{
	return bool4x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool4x2 operator+=( bool4x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x2 operator+( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool4x2 operator+=( bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 operator-( const bool4x2& lhs, const bool32_t rhs )
{
	return bool4x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool4x2 operator-=( bool4x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x2 operator-( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool4x2 operator-=( bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 operator*( const bool4x2& lhs, const bool32_t rhs )
{
	return bool4x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool4x2 operator*=( bool4x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x2 operator*( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool4x2 operator*=( bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x2 operator/( const bool4x2& lhs, const bool32_t rhs )
{
	return bool4x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool4x2 operator/=( bool4x2& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x2 operator/( const bool4x2& lhs, const bool4x2& rhs )
{
	return bool4x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool4x2 operator/=( bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool4x2 operator++( bool4x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x2 operator++( bool4x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool4x2 operator--( bool4x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x2 operator--( bool4x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool4x2* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] ) &&
		all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool4x2* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] ) ||
		any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat.rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
	mat.rows[3] = HLML_CONSTRUCT( bool2 ) { false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool2x4 transpose( const bool4x2& mat )
{
	return HLML_CONSTRUCT( bool2x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

// bool4x3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool4x3& lhs, const bool4x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool4x3& lhs, const bool4x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<=( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>=( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 operator+( const bool4x3& lhs, const bool32_t rhs )
{
	return bool4x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool4x3 operator+=( bool4x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x3 operator+( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool4x3 operator+=( bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 operator-( const bool4x3& lhs, const bool32_t rhs )
{
	return bool4x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool4x3 operator-=( bool4x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x3 operator-( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool4x3 operator-=( bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 operator*( const bool4x3& lhs, const bool32_t rhs )
{
	return bool4x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool4x3 operator*=( bool4x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x3 operator*( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool4x3 operator*=( bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x3 operator/( const bool4x3& lhs, const bool32_t rhs )
{
	return bool4x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool4x3 operator/=( bool4x3& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x3 operator/( const bool4x3& lhs, const bool4x3& rhs )
{
	return bool4x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool4x3 operator/=( bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool4x3 operator++( bool4x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x3 operator++( bool4x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool4x3 operator--( bool4x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x3 operator--( bool4x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool4x3* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] ) &&
		all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool4x3* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] ) ||
		any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat.rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
	mat.rows[3] = HLML_CONSTRUCT( bool3 ) { false, false, false };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool3x4 transpose( const bool4x3& mat )
{
	return HLML_CONSTRUCT( bool3x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

// bool4x4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const bool4x4& lhs, const bool4x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const bool4x4& lhs, const bool4x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<=( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>=( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 operator+( const bool4x4& lhs, const bool32_t rhs )
{
	return bool4x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE bool4x4 operator+=( bool4x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE bool4x4 operator+( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE bool4x4 operator+=( bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 operator-( const bool4x4& lhs, const bool32_t rhs )
{
	return bool4x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE bool4x4 operator-=( bool4x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE bool4x4 operator-( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE bool4x4 operator-=( bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 operator*( const bool4x4& lhs, const bool32_t rhs )
{
	return bool4x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE bool4x4 operator*=( bool4x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE bool4x4 operator*( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE bool4x4 operator*=( bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE bool4x4 operator/( const bool4x4& lhs, const bool32_t rhs )
{
	return bool4x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE bool4x4 operator/=( bool4x4& lhs, const bool32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE bool4x4 operator/( const bool4x4& lhs, const bool4x4& rhs )
{
	return bool4x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE bool4x4 operator/=( bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE bool4x4 operator++( bool4x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x4 operator++( bool4x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE bool4x4 operator--( bool4x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE bool4x4 operator--( bool4x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool all( const bool4x4* x )
{
	return
		all( &x->rows[0] ) &&
		all( &x->rows[1] ) &&
		all( &x->rows[2] ) &&
		all( &x->rows[3] );
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool any( const bool4x4* x )
{
	return
		any( &x->rows[0] ) ||
		any( &x->rows[1] ) ||
		any( &x->rows[2] ) ||
		any( &x->rows[3] );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( bool4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat.rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
	mat.rows[3] = HLML_CONSTRUCT( bool4 ) { false, false, false, true };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE bool4x4 transpose( const bool4x4& mat )
{
	return HLML_CONSTRUCT( bool4x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

// int2x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x2 sign( const int2x2& x )
{
	return int2x2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int2x2 min( const int2x2& x, const int2x2& y )
{
	return int2x2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int2x2 max( const int2x2& x, const int2x2& y )
{
	return int2x2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int2x2 clamp( const int2x2& x, const int2x2& low, const int2x2& high )
{
	return int2x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int2x2 saturate( const int2x2& x )
{
	return int2x2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int2x2& lhs, const int2x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int2x2& lhs, const int2x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<( const int2x2& lhs, const int2x2& rhs )
{
	return bool2x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<=( const int2x2& lhs, const int2x2& rhs )
{
	return bool2x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>( const int2x2& lhs, const int2x2& rhs )
{
	return bool2x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>=( const int2x2& lhs, const int2x2& rhs )
{
	return bool2x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator+( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int2x2 operator+=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x2 operator+( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int2x2 operator+=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator-( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int2x2 operator-=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x2 operator-( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int2x2 operator-=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator*( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int2x2 operator*=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x2 operator*( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int2x2 operator*=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator/( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int2x2 operator/=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x2 operator/( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int2x2 operator/=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int2x2 operator++( int2x2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x2 operator++( int2x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int2x2 operator--( int2x2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x2 operator--( int2x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int2x2 operator-( const int2x2& x )
{
	return int2x2(
		-x[0],
		-x[1]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int2x2 operator~( const int2x2& x )
{
	return int2x2(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator&( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int2x2 operator&=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x2 operator&( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int2x2 operator&=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator|( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int2x2 operator|=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x2 operator|( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int2x2 operator|=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator^( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int2x2 operator^=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x2 operator^( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int2x2 operator^=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator<<( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int2x2 operator<<=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x2 operator<<( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int2x2 operator<<=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x2 operator>>( const int2x2& lhs, const int32_t rhs )
{
	return int2x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int2x2 operator>>=( int2x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x2 operator>>( const int2x2& lhs, const int2x2& rhs )
{
	return int2x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int2x2 operator>>=( int2x2& lhs, const int2x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x2 transpose( const int2x2& mat )
{
	return HLML_CONSTRUCT( int2x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t determinant( const int2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 mul( const int2x2& lhs, const int2x2& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int2 mul( const int2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y )
	};
}

// int2x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x3 sign( const int2x3& x )
{
	return int2x3(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int2x3 min( const int2x3& x, const int2x3& y )
{
	return int2x3(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int2x3 max( const int2x3& x, const int2x3& y )
{
	return int2x3(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int2x3 clamp( const int2x3& x, const int2x3& low, const int2x3& high )
{
	return int2x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int2x3 saturate( const int2x3& x )
{
	return int2x3(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int2x3& lhs, const int2x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int2x3& lhs, const int2x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<( const int2x3& lhs, const int2x3& rhs )
{
	return bool2x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<=( const int2x3& lhs, const int2x3& rhs )
{
	return bool2x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>( const int2x3& lhs, const int2x3& rhs )
{
	return bool2x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>=( const int2x3& lhs, const int2x3& rhs )
{
	return bool2x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator+( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int2x3 operator+=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x3 operator+( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int2x3 operator+=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator-( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int2x3 operator-=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x3 operator-( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int2x3 operator-=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator*( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int2x3 operator*=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x3 operator*( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int2x3 operator*=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator/( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int2x3 operator/=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x3 operator/( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int2x3 operator/=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int2x3 operator++( int2x3& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x3 operator++( int2x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int2x3 operator--( int2x3& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x3 operator--( int2x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int2x3 operator-( const int2x3& x )
{
	return int2x3(
		-x[0],
		-x[1]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int2x3 operator~( const int2x3& x )
{
	return int2x3(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator&( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int2x3 operator&=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x3 operator&( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int2x3 operator&=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator|( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int2x3 operator|=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x3 operator|( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int2x3 operator|=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator^( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int2x3 operator^=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x3 operator^( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int2x3 operator^=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator<<( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int2x3 operator<<=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x3 operator<<( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int2x3 operator<<=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x3 operator>>( const int2x3& lhs, const int32_t rhs )
{
	return int2x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int2x3 operator>>=( int2x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x3 operator>>( const int2x3& lhs, const int2x3& rhs )
{
	return int2x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int2x3 operator>>=( int2x3& lhs, const int2x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x2 transpose( const int2x3& mat )
{
	return HLML_CONSTRUCT( int3x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 mul( const int2x3& lhs, const int3x2& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// int2x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x4 sign( const int2x4& x )
{
	return int2x4(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int2x4 min( const int2x4& x, const int2x4& y )
{
	return int2x4(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int2x4 max( const int2x4& x, const int2x4& y )
{
	return int2x4(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int2x4 clamp( const int2x4& x, const int2x4& low, const int2x4& high )
{
	return int2x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int2x4 saturate( const int2x4& x )
{
	return int2x4(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int2x4& lhs, const int2x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int2x4& lhs, const int2x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<( const int2x4& lhs, const int2x4& rhs )
{
	return bool2x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<=( const int2x4& lhs, const int2x4& rhs )
{
	return bool2x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>( const int2x4& lhs, const int2x4& rhs )
{
	return bool2x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>=( const int2x4& lhs, const int2x4& rhs )
{
	return bool2x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator+( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int2x4 operator+=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int2x4 operator+( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int2x4 operator+=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator-( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int2x4 operator-=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int2x4 operator-( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int2x4 operator-=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator*( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int2x4 operator*=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int2x4 operator*( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int2x4 operator*=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator/( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int2x4 operator/=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int2x4 operator/( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int2x4 operator/=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int2x4 operator++( int2x4& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x4 operator++( int2x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int2x4 operator--( int2x4& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int2x4 operator--( int2x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int2x4 operator-( const int2x4& x )
{
	return int2x4(
		-x[0],
		-x[1]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int2x4 operator~( const int2x4& x )
{
	return int2x4(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator&( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int2x4 operator&=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int2x4 operator&( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int2x4 operator&=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator|( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int2x4 operator|=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int2x4 operator|( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int2x4 operator|=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator^( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int2x4 operator^=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int2x4 operator^( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int2x4 operator^=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator<<( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int2x4 operator<<=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int2x4 operator<<( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int2x4 operator<<=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int2x4 operator>>( const int2x4& lhs, const int32_t rhs )
{
	return int2x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int2x4 operator>>=( int2x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int2x4 operator>>( const int2x4& lhs, const int2x4& rhs )
{
	return int2x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int2x4 operator>>=( int2x4& lhs, const int2x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x2 transpose( const int2x4& mat )
{
	return HLML_CONSTRUCT( int4x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int2x2 mul( const int2x4& lhs, const int4x2& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( int2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// int3x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x2 sign( const int3x2& x )
{
	return int3x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int3x2 min( const int3x2& x, const int3x2& y )
{
	return int3x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int3x2 max( const int3x2& x, const int3x2& y )
{
	return int3x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int3x2 clamp( const int3x2& x, const int3x2& low, const int3x2& high )
{
	return int3x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int3x2 saturate( const int3x2& x )
{
	return int3x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int3x2& lhs, const int3x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int3x2& lhs, const int3x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<( const int3x2& lhs, const int3x2& rhs )
{
	return bool3x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<=( const int3x2& lhs, const int3x2& rhs )
{
	return bool3x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>( const int3x2& lhs, const int3x2& rhs )
{
	return bool3x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>=( const int3x2& lhs, const int3x2& rhs )
{
	return bool3x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator+( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int3x2 operator+=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x2 operator+( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int3x2 operator+=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator-( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int3x2 operator-=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x2 operator-( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int3x2 operator-=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator*( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int3x2 operator*=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x2 operator*( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int3x2 operator*=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator/( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int3x2 operator/=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x2 operator/( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int3x2 operator/=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int3x2 operator++( int3x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x2 operator++( int3x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int3x2 operator--( int3x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x2 operator--( int3x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int3x2 operator-( const int3x2& x )
{
	return int3x2(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int3x2 operator~( const int3x2& x )
{
	return int3x2(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator&( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int3x2 operator&=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x2 operator&( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int3x2 operator&=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator|( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int3x2 operator|=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x2 operator|( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int3x2 operator|=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator^( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int3x2 operator^=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x2 operator^( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int3x2 operator^=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator<<( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int3x2 operator<<=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x2 operator<<( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int3x2 operator<<=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x2 operator>>( const int3x2& lhs, const int32_t rhs )
{
	return int3x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int3x2 operator>>=( int3x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x2 operator>>( const int3x2& lhs, const int3x2& rhs )
{
	return int3x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int3x2 operator>>=( int3x2& lhs, const int3x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat.rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x3 transpose( const int3x2& mat )
{
	return HLML_CONSTRUCT( int2x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 mul( const int3x2& lhs, const int2x3& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// int3x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x3 sign( const int3x3& x )
{
	return int3x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int3x3 min( const int3x3& x, const int3x3& y )
{
	return int3x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int3x3 max( const int3x3& x, const int3x3& y )
{
	return int3x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int3x3 clamp( const int3x3& x, const int3x3& low, const int3x3& high )
{
	return int3x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int3x3 saturate( const int3x3& x )
{
	return int3x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int3x3& lhs, const int3x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int3x3& lhs, const int3x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<( const int3x3& lhs, const int3x3& rhs )
{
	return bool3x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<=( const int3x3& lhs, const int3x3& rhs )
{
	return bool3x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>( const int3x3& lhs, const int3x3& rhs )
{
	return bool3x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>=( const int3x3& lhs, const int3x3& rhs )
{
	return bool3x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator+( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int3x3 operator+=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x3 operator+( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int3x3 operator+=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator-( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int3x3 operator-=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x3 operator-( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int3x3 operator-=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator*( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int3x3 operator*=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x3 operator*( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int3x3 operator*=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator/( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int3x3 operator/=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x3 operator/( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int3x3 operator/=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int3x3 operator++( int3x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x3 operator++( int3x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int3x3 operator--( int3x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x3 operator--( int3x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int3x3 operator-( const int3x3& x )
{
	return int3x3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int3x3 operator~( const int3x3& x )
{
	return int3x3(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator&( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int3x3 operator&=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x3 operator&( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int3x3 operator&=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator|( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int3x3 operator|=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x3 operator|( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int3x3 operator|=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator^( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int3x3 operator^=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x3 operator^( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int3x3 operator^=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator<<( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int3x3 operator<<=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x3 operator<<( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int3x3 operator<<=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x3 operator>>( const int3x3& lhs, const int32_t rhs )
{
	return int3x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int3x3 operator>>=( int3x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x3 operator>>( const int3x3& lhs, const int3x3& rhs )
{
	return int3x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int3x3 operator>>=( int3x3& lhs, const int3x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x3 transpose( const int3x3& mat )
{
	return HLML_CONSTRUCT( int3x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t determinant( const int3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 mul( const int3x3& lhs, const int3x3& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int3 mul( const int3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z )
	};
}

// int3x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x4 sign( const int3x4& x )
{
	return int3x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int3x4 min( const int3x4& x, const int3x4& y )
{
	return int3x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int3x4 max( const int3x4& x, const int3x4& y )
{
	return int3x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int3x4 clamp( const int3x4& x, const int3x4& low, const int3x4& high )
{
	return int3x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int3x4 saturate( const int3x4& x )
{
	return int3x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int3x4& lhs, const int3x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int3x4& lhs, const int3x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<( const int3x4& lhs, const int3x4& rhs )
{
	return bool3x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<=( const int3x4& lhs, const int3x4& rhs )
{
	return bool3x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>( const int3x4& lhs, const int3x4& rhs )
{
	return bool3x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>=( const int3x4& lhs, const int3x4& rhs )
{
	return bool3x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator+( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int3x4 operator+=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int3x4 operator+( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int3x4 operator+=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator-( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int3x4 operator-=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int3x4 operator-( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int3x4 operator-=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator*( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int3x4 operator*=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int3x4 operator*( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int3x4 operator*=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator/( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int3x4 operator/=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int3x4 operator/( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int3x4 operator/=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int3x4 operator++( int3x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x4 operator++( int3x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int3x4 operator--( int3x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int3x4 operator--( int3x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int3x4 operator-( const int3x4& x )
{
	return int3x4(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int3x4 operator~( const int3x4& x )
{
	return int3x4(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator&( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int3x4 operator&=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int3x4 operator&( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int3x4 operator&=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator|( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int3x4 operator|=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int3x4 operator|( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int3x4 operator|=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator^( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int3x4 operator^=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int3x4 operator^( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int3x4 operator^=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator<<( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int3x4 operator<<=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int3x4 operator<<( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int3x4 operator<<=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int3x4 operator>>( const int3x4& lhs, const int32_t rhs )
{
	return int3x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int3x4 operator>>=( int3x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int3x4 operator>>( const int3x4& lhs, const int3x4& rhs )
{
	return int3x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int3x4 operator>>=( int3x4& lhs, const int3x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x3 transpose( const int3x4& mat )
{
	return HLML_CONSTRUCT( int4x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int3x3 mul( const int3x4& lhs, const int4x3& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( int3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// int4x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x2 sign( const int4x2& x )
{
	return int4x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int4x2 min( const int4x2& x, const int4x2& y )
{
	return int4x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int4x2 max( const int4x2& x, const int4x2& y )
{
	return int4x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int4x2 clamp( const int4x2& x, const int4x2& low, const int4x2& high )
{
	return int4x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int4x2 saturate( const int4x2& x )
{
	return int4x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int4x2& lhs, const int4x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int4x2& lhs, const int4x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<( const int4x2& lhs, const int4x2& rhs )
{
	return bool4x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<=( const int4x2& lhs, const int4x2& rhs )
{
	return bool4x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>( const int4x2& lhs, const int4x2& rhs )
{
	return bool4x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>=( const int4x2& lhs, const int4x2& rhs )
{
	return bool4x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator+( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int4x2 operator+=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x2 operator+( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int4x2 operator+=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator-( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int4x2 operator-=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x2 operator-( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int4x2 operator-=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator*( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int4x2 operator*=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x2 operator*( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int4x2 operator*=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator/( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int4x2 operator/=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x2 operator/( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int4x2 operator/=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int4x2 operator++( int4x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x2 operator++( int4x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int4x2 operator--( int4x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x2 operator--( int4x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int4x2 operator-( const int4x2& x )
{
	return int4x2(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int4x2 operator~( const int4x2& x )
{
	return int4x2(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator&( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int4x2 operator&=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x2 operator&( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int4x2 operator&=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator|( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int4x2 operator|=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x2 operator|( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int4x2 operator|=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator^( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int4x2 operator^=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x2 operator^( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int4x2 operator^=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator<<( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int4x2 operator<<=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x2 operator<<( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int4x2 operator<<=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x2 operator>>( const int4x2& lhs, const int32_t rhs )
{
	return int4x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int4x2 operator>>=( int4x2& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x2 operator>>( const int4x2& lhs, const int4x2& rhs )
{
	return int4x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int4x2 operator>>=( int4x2& lhs, const int4x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat.rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
	mat.rows[3] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int2x4 transpose( const int4x2& mat )
{
	return HLML_CONSTRUCT( int2x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 mul( const int4x2& lhs, const int2x4& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];
	int2 row3 = lhs.rows[3];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	int2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// int4x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x3 sign( const int4x3& x )
{
	return int4x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int4x3 min( const int4x3& x, const int4x3& y )
{
	return int4x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int4x3 max( const int4x3& x, const int4x3& y )
{
	return int4x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int4x3 clamp( const int4x3& x, const int4x3& low, const int4x3& high )
{
	return int4x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int4x3 saturate( const int4x3& x )
{
	return int4x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int4x3& lhs, const int4x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int4x3& lhs, const int4x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<( const int4x3& lhs, const int4x3& rhs )
{
	return bool4x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<=( const int4x3& lhs, const int4x3& rhs )
{
	return bool4x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>( const int4x3& lhs, const int4x3& rhs )
{
	return bool4x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>=( const int4x3& lhs, const int4x3& rhs )
{
	return bool4x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator+( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int4x3 operator+=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x3 operator+( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int4x3 operator+=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator-( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int4x3 operator-=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x3 operator-( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int4x3 operator-=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator*( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int4x3 operator*=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x3 operator*( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int4x3 operator*=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator/( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int4x3 operator/=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x3 operator/( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int4x3 operator/=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int4x3 operator++( int4x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x3 operator++( int4x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int4x3 operator--( int4x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x3 operator--( int4x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int4x3 operator-( const int4x3& x )
{
	return int4x3(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int4x3 operator~( const int4x3& x )
{
	return int4x3(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator&( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int4x3 operator&=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x3 operator&( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int4x3 operator&=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator|( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int4x3 operator|=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x3 operator|( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int4x3 operator|=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator^( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int4x3 operator^=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x3 operator^( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int4x3 operator^=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator<<( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int4x3 operator<<=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x3 operator<<( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int4x3 operator<<=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x3 operator>>( const int4x3& lhs, const int32_t rhs )
{
	return int4x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int4x3 operator>>=( int4x3& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x3 operator>>( const int4x3& lhs, const int4x3& rhs )
{
	return int4x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int4x3 operator>>=( int4x3& lhs, const int4x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
	mat.rows[3] = HLML_CONSTRUCT( int3 ) { 0, 0, 0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int3x4 transpose( const int4x3& mat )
{
	return HLML_CONSTRUCT( int3x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 mul( const int4x3& lhs, const int3x4& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];
	int3 row3 = lhs.rows[3];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	int3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// int4x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x4 sign( const int4x4& x )
{
	return int4x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE int4x4 min( const int4x4& x, const int4x4& y )
{
	return int4x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE int4x4 max( const int4x4& x, const int4x4& y )
{
	return int4x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE int4x4 clamp( const int4x4& x, const int4x4& low, const int4x4& high )
{
	return int4x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE int4x4 saturate( const int4x4& x )
{
	return int4x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const int4x4& lhs, const int4x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const int4x4& lhs, const int4x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<( const int4x4& lhs, const int4x4& rhs )
{
	return bool4x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<=( const int4x4& lhs, const int4x4& rhs )
{
	return bool4x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>( const int4x4& lhs, const int4x4& rhs )
{
	return bool4x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>=( const int4x4& lhs, const int4x4& rhs )
{
	return bool4x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator+( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE int4x4 operator+=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE int4x4 operator+( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE int4x4 operator+=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator-( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE int4x4 operator-=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE int4x4 operator-( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE int4x4 operator-=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator*( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE int4x4 operator*=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE int4x4 operator*( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE int4x4 operator*=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator/( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE int4x4 operator/=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE int4x4 operator/( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE int4x4 operator/=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE int4x4 operator++( int4x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x4 operator++( int4x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE int4x4 operator--( int4x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE int4x4 operator--( int4x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE int4x4 operator-( const int4x4& x )
{
	return int4x4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE int4x4 operator~( const int4x4& x )
{
	return int4x4(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator&( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE int4x4 operator&=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE int4x4 operator&( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE int4x4 operator&=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator|( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE int4x4 operator|=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE int4x4 operator|( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE int4x4 operator|=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator^( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE int4x4 operator^=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE int4x4 operator^( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE int4x4 operator^=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator<<( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE int4x4 operator<<=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE int4x4 operator<<( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE int4x4 operator<<=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE int4x4 operator>>( const int4x4& lhs, const int32_t rhs )
{
	return int4x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE int4x4 operator>>=( int4x4& lhs, const int32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE int4x4 operator>>( const int4x4& lhs, const int4x4& rhs )
{
	return int4x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE int4x4 operator>>=( int4x4& lhs, const int4x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( int4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
	mat.rows[3] = HLML_CONSTRUCT( int4 ) { 0, 0, 0, 1 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE int4x4 transpose( const int4x4& mat )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE int32_t determinant( const int4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	int32_t sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	int32_t sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	int32_t sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	int32_t sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	int32_t sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	int32_t sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	int4 cofactor = HLML_CONSTRUCT( int4 )
	{
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE int4x4 mul( const int4x4& lhs, const int4x4& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];
	int4 row3 = lhs.rows[3];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	int4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( int4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE int4 mul( const int4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ) + ( lhs.w * rhs.rows[3].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ) + ( lhs.w * rhs.rows[3].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z ) + ( lhs.w * rhs.rows[3].z ),
		( lhs.x * rhs.rows[0].w ) + ( lhs.y * rhs.rows[1].w ) + ( lhs.z * rhs.rows[2].w ) + ( lhs.w * rhs.rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE int4x4 translate( const int4x4& mat, const int3& vec )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE int4x4 scale( const int4x4& mat, const int3& scale )
{
	return HLML_CONSTRUCT( int4x4 )
	{
		mat.rows[0].x * scale.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * scale.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * scale.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

// uint2x2
// Performs a min function on each row of the matrix.
HLML_INLINE uint2x2 min( const uint2x2& x, const uint2x2& y )
{
	return uint2x2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint2x2 max( const uint2x2& x, const uint2x2& y )
{
	return uint2x2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint2x2 clamp( const uint2x2& x, const uint2x2& low, const uint2x2& high )
{
	return uint2x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint2x2 saturate( const uint2x2& x )
{
	return uint2x2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint2x2& lhs, const uint2x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint2x2& lhs, const uint2x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<( const uint2x2& lhs, const uint2x2& rhs )
{
	return bool2x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<=( const uint2x2& lhs, const uint2x2& rhs )
{
	return bool2x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>( const uint2x2& lhs, const uint2x2& rhs )
{
	return bool2x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>=( const uint2x2& lhs, const uint2x2& rhs )
{
	return bool2x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator+( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint2x2 operator+=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x2 operator+( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint2x2 operator+=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator-( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint2x2 operator-=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x2 operator-( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint2x2 operator-=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator*( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint2x2 operator*=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x2 operator*( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint2x2 operator*=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator/( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint2x2 operator/=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x2 operator/( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint2x2 operator/=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint2x2 operator++( uint2x2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x2 operator++( uint2x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint2x2 operator--( uint2x2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x2 operator--( uint2x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint2x2 operator-( const uint2x2& x )
{
	return uint2x2(
		-x[0],
		-x[1]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint2x2 operator~( const uint2x2& x )
{
	return uint2x2(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator&( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint2x2 operator&=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x2 operator&( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint2x2 operator&=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator|( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint2x2 operator|=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x2 operator|( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint2x2 operator|=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator^( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint2x2 operator^=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x2 operator^( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint2x2 operator^=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator<<( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint2x2 operator<<=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x2 operator<<( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint2x2 operator<<=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x2 operator>>( const uint2x2& lhs, const uint32_t rhs )
{
	return uint2x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint2x2 operator>>=( uint2x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x2 operator>>( const uint2x2& lhs, const uint2x2& rhs )
{
	return uint2x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint2x2 operator>>=( uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x2 transpose( const uint2x2& mat )
{
	return HLML_CONSTRUCT( uint2x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 mul( const uint2x2& lhs, const uint2x2& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint2 mul( const uint2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y )
	};
}

// uint2x3
// Performs a min function on each row of the matrix.
HLML_INLINE uint2x3 min( const uint2x3& x, const uint2x3& y )
{
	return uint2x3(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint2x3 max( const uint2x3& x, const uint2x3& y )
{
	return uint2x3(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint2x3 clamp( const uint2x3& x, const uint2x3& low, const uint2x3& high )
{
	return uint2x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint2x3 saturate( const uint2x3& x )
{
	return uint2x3(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint2x3& lhs, const uint2x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint2x3& lhs, const uint2x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<( const uint2x3& lhs, const uint2x3& rhs )
{
	return bool2x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<=( const uint2x3& lhs, const uint2x3& rhs )
{
	return bool2x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>( const uint2x3& lhs, const uint2x3& rhs )
{
	return bool2x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>=( const uint2x3& lhs, const uint2x3& rhs )
{
	return bool2x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator+( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint2x3 operator+=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x3 operator+( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint2x3 operator+=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator-( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint2x3 operator-=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x3 operator-( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint2x3 operator-=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator*( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint2x3 operator*=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x3 operator*( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint2x3 operator*=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator/( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint2x3 operator/=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x3 operator/( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint2x3 operator/=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint2x3 operator++( uint2x3& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x3 operator++( uint2x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint2x3 operator--( uint2x3& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x3 operator--( uint2x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint2x3 operator-( const uint2x3& x )
{
	return uint2x3(
		-x[0],
		-x[1]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint2x3 operator~( const uint2x3& x )
{
	return uint2x3(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator&( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint2x3 operator&=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x3 operator&( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint2x3 operator&=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator|( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint2x3 operator|=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x3 operator|( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint2x3 operator|=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator^( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint2x3 operator^=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x3 operator^( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint2x3 operator^=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator<<( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint2x3 operator<<=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x3 operator<<( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint2x3 operator<<=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x3 operator>>( const uint2x3& lhs, const uint32_t rhs )
{
	return uint2x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint2x3 operator>>=( uint2x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x3 operator>>( const uint2x3& lhs, const uint2x3& rhs )
{
	return uint2x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint2x3 operator>>=( uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x2 transpose( const uint2x3& mat )
{
	return HLML_CONSTRUCT( uint3x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 mul( const uint2x3& lhs, const uint3x2& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// uint2x4
// Performs a min function on each row of the matrix.
HLML_INLINE uint2x4 min( const uint2x4& x, const uint2x4& y )
{
	return uint2x4(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint2x4 max( const uint2x4& x, const uint2x4& y )
{
	return uint2x4(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint2x4 clamp( const uint2x4& x, const uint2x4& low, const uint2x4& high )
{
	return uint2x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint2x4 saturate( const uint2x4& x )
{
	return uint2x4(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint2x4& lhs, const uint2x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint2x4& lhs, const uint2x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<( const uint2x4& lhs, const uint2x4& rhs )
{
	return bool2x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<=( const uint2x4& lhs, const uint2x4& rhs )
{
	return bool2x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>( const uint2x4& lhs, const uint2x4& rhs )
{
	return bool2x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>=( const uint2x4& lhs, const uint2x4& rhs )
{
	return bool2x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator+( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint2x4 operator+=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint2x4 operator+( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint2x4 operator+=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator-( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint2x4 operator-=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint2x4 operator-( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint2x4 operator-=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator*( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint2x4 operator*=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint2x4 operator*( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint2x4 operator*=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator/( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint2x4 operator/=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint2x4 operator/( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint2x4 operator/=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint2x4 operator++( uint2x4& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x4 operator++( uint2x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint2x4 operator--( uint2x4& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint2x4 operator--( uint2x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint2x4 operator-( const uint2x4& x )
{
	return uint2x4(
		-x[0],
		-x[1]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint2x4 operator~( const uint2x4& x )
{
	return uint2x4(
		~x[0],
		~x[1]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator&( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] & rhs,
		lhs[1] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint2x4 operator&=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint2x4 operator&( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint2x4 operator&=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator|( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] | rhs,
		lhs[1] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint2x4 operator|=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint2x4 operator|( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint2x4 operator|=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator^( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint2x4 operator^=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint2x4 operator^( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint2x4 operator^=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator<<( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] << rhs,
		lhs[1] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint2x4 operator<<=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint2x4 operator<<( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint2x4 operator<<=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint2x4 operator>>( const uint2x4& lhs, const uint32_t rhs )
{
	return uint2x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint2x4 operator>>=( uint2x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint2x4 operator>>( const uint2x4& lhs, const uint2x4& rhs )
{
	return uint2x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint2x4 operator>>=( uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x2 transpose( const uint2x4& mat )
{
	return HLML_CONSTRUCT( uint4x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint2x2 mul( const uint2x4& lhs, const uint4x2& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( uint2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// uint3x2
// Performs a min function on each row of the matrix.
HLML_INLINE uint3x2 min( const uint3x2& x, const uint3x2& y )
{
	return uint3x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint3x2 max( const uint3x2& x, const uint3x2& y )
{
	return uint3x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint3x2 clamp( const uint3x2& x, const uint3x2& low, const uint3x2& high )
{
	return uint3x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint3x2 saturate( const uint3x2& x )
{
	return uint3x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint3x2& lhs, const uint3x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint3x2& lhs, const uint3x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<( const uint3x2& lhs, const uint3x2& rhs )
{
	return bool3x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<=( const uint3x2& lhs, const uint3x2& rhs )
{
	return bool3x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>( const uint3x2& lhs, const uint3x2& rhs )
{
	return bool3x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>=( const uint3x2& lhs, const uint3x2& rhs )
{
	return bool3x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator+( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint3x2 operator+=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x2 operator+( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint3x2 operator+=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator-( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint3x2 operator-=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x2 operator-( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint3x2 operator-=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator*( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint3x2 operator*=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x2 operator*( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint3x2 operator*=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator/( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint3x2 operator/=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x2 operator/( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint3x2 operator/=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint3x2 operator++( uint3x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x2 operator++( uint3x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint3x2 operator--( uint3x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x2 operator--( uint3x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint3x2 operator-( const uint3x2& x )
{
	return uint3x2(
		-x[0],
		-x[1],
		-x[2]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint3x2 operator~( const uint3x2& x )
{
	return uint3x2(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator&( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint3x2 operator&=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x2 operator&( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint3x2 operator&=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator|( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint3x2 operator|=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x2 operator|( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint3x2 operator|=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator^( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint3x2 operator^=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x2 operator^( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint3x2 operator^=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator<<( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint3x2 operator<<=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x2 operator<<( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint3x2 operator<<=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x2 operator>>( const uint3x2& lhs, const uint32_t rhs )
{
	return uint3x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint3x2 operator>>=( uint3x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x2 operator>>( const uint3x2& lhs, const uint3x2& rhs )
{
	return uint3x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint3x2 operator>>=( uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat.rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x3 transpose( const uint3x2& mat )
{
	return HLML_CONSTRUCT( uint2x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 mul( const uint3x2& lhs, const uint2x3& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// uint3x3
// Performs a min function on each row of the matrix.
HLML_INLINE uint3x3 min( const uint3x3& x, const uint3x3& y )
{
	return uint3x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint3x3 max( const uint3x3& x, const uint3x3& y )
{
	return uint3x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint3x3 clamp( const uint3x3& x, const uint3x3& low, const uint3x3& high )
{
	return uint3x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint3x3 saturate( const uint3x3& x )
{
	return uint3x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint3x3& lhs, const uint3x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint3x3& lhs, const uint3x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<( const uint3x3& lhs, const uint3x3& rhs )
{
	return bool3x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<=( const uint3x3& lhs, const uint3x3& rhs )
{
	return bool3x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>( const uint3x3& lhs, const uint3x3& rhs )
{
	return bool3x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>=( const uint3x3& lhs, const uint3x3& rhs )
{
	return bool3x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator+( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint3x3 operator+=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x3 operator+( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint3x3 operator+=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator-( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint3x3 operator-=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x3 operator-( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint3x3 operator-=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator*( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint3x3 operator*=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x3 operator*( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint3x3 operator*=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator/( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint3x3 operator/=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x3 operator/( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint3x3 operator/=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint3x3 operator++( uint3x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x3 operator++( uint3x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint3x3 operator--( uint3x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x3 operator--( uint3x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint3x3 operator-( const uint3x3& x )
{
	return uint3x3(
		-x[0],
		-x[1],
		-x[2]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint3x3 operator~( const uint3x3& x )
{
	return uint3x3(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator&( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint3x3 operator&=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x3 operator&( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint3x3 operator&=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator|( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint3x3 operator|=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x3 operator|( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint3x3 operator|=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator^( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint3x3 operator^=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x3 operator^( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint3x3 operator^=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator<<( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint3x3 operator<<=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x3 operator<<( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint3x3 operator<<=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x3 operator>>( const uint3x3& lhs, const uint32_t rhs )
{
	return uint3x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint3x3 operator>>=( uint3x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x3 operator>>( const uint3x3& lhs, const uint3x3& rhs )
{
	return uint3x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint3x3 operator>>=( uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x3 transpose( const uint3x3& mat )
{
	return HLML_CONSTRUCT( uint3x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 mul( const uint3x3& lhs, const uint3x3& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint3 mul( const uint3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z )
	};
}

// uint3x4
// Performs a min function on each row of the matrix.
HLML_INLINE uint3x4 min( const uint3x4& x, const uint3x4& y )
{
	return uint3x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint3x4 max( const uint3x4& x, const uint3x4& y )
{
	return uint3x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint3x4 clamp( const uint3x4& x, const uint3x4& low, const uint3x4& high )
{
	return uint3x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint3x4 saturate( const uint3x4& x )
{
	return uint3x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint3x4& lhs, const uint3x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint3x4& lhs, const uint3x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<( const uint3x4& lhs, const uint3x4& rhs )
{
	return bool3x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<=( const uint3x4& lhs, const uint3x4& rhs )
{
	return bool3x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>( const uint3x4& lhs, const uint3x4& rhs )
{
	return bool3x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>=( const uint3x4& lhs, const uint3x4& rhs )
{
	return bool3x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator+( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint3x4 operator+=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint3x4 operator+( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint3x4 operator+=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator-( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint3x4 operator-=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint3x4 operator-( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint3x4 operator-=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator*( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint3x4 operator*=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint3x4 operator*( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint3x4 operator*=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator/( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint3x4 operator/=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint3x4 operator/( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint3x4 operator/=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint3x4 operator++( uint3x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x4 operator++( uint3x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint3x4 operator--( uint3x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint3x4 operator--( uint3x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint3x4 operator-( const uint3x4& x )
{
	return uint3x4(
		-x[0],
		-x[1],
		-x[2]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint3x4 operator~( const uint3x4& x )
{
	return uint3x4(
		~x[0],
		~x[1],
		~x[2]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator&( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint3x4 operator&=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint3x4 operator&( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint3x4 operator&=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator|( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint3x4 operator|=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint3x4 operator|( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint3x4 operator|=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator^( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint3x4 operator^=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint3x4 operator^( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint3x4 operator^=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator<<( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint3x4 operator<<=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint3x4 operator<<( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint3x4 operator<<=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint3x4 operator>>( const uint3x4& lhs, const uint32_t rhs )
{
	return uint3x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint3x4 operator>>=( uint3x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint3x4 operator>>( const uint3x4& lhs, const uint3x4& rhs )
{
	return uint3x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint3x4 operator>>=( uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x3 transpose( const uint3x4& mat )
{
	return HLML_CONSTRUCT( uint4x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint3x3 mul( const uint3x4& lhs, const uint4x3& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( uint3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// uint4x2
// Performs a min function on each row of the matrix.
HLML_INLINE uint4x2 min( const uint4x2& x, const uint4x2& y )
{
	return uint4x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint4x2 max( const uint4x2& x, const uint4x2& y )
{
	return uint4x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint4x2 clamp( const uint4x2& x, const uint4x2& low, const uint4x2& high )
{
	return uint4x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint4x2 saturate( const uint4x2& x )
{
	return uint4x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint4x2& lhs, const uint4x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint4x2& lhs, const uint4x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<( const uint4x2& lhs, const uint4x2& rhs )
{
	return bool4x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<=( const uint4x2& lhs, const uint4x2& rhs )
{
	return bool4x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>( const uint4x2& lhs, const uint4x2& rhs )
{
	return bool4x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>=( const uint4x2& lhs, const uint4x2& rhs )
{
	return bool4x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator+( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint4x2 operator+=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x2 operator+( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint4x2 operator+=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator-( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint4x2 operator-=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x2 operator-( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint4x2 operator-=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator*( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint4x2 operator*=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x2 operator*( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint4x2 operator*=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator/( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint4x2 operator/=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x2 operator/( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint4x2 operator/=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint4x2 operator++( uint4x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x2 operator++( uint4x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint4x2 operator--( uint4x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x2 operator--( uint4x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint4x2 operator-( const uint4x2& x )
{
	return uint4x2(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint4x2 operator~( const uint4x2& x )
{
	return uint4x2(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator&( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint4x2 operator&=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x2 operator&( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint4x2 operator&=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator|( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint4x2 operator|=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x2 operator|( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint4x2 operator|=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator^( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint4x2 operator^=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x2 operator^( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint4x2 operator^=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator<<( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint4x2 operator<<=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x2 operator<<( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint4x2 operator<<=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x2 operator>>( const uint4x2& lhs, const uint32_t rhs )
{
	return uint4x2(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint4x2 operator>>=( uint4x2& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x2 operator>>( const uint4x2& lhs, const uint4x2& rhs )
{
	return uint4x2(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint4x2 operator>>=( uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat.rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
	mat.rows[3] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint2x4 transpose( const uint4x2& mat )
{
	return HLML_CONSTRUCT( uint2x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 mul( const uint4x2& lhs, const uint2x4& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];
	uint2 row3 = lhs.rows[3];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	uint2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// uint4x3
// Performs a min function on each row of the matrix.
HLML_INLINE uint4x3 min( const uint4x3& x, const uint4x3& y )
{
	return uint4x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint4x3 max( const uint4x3& x, const uint4x3& y )
{
	return uint4x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint4x3 clamp( const uint4x3& x, const uint4x3& low, const uint4x3& high )
{
	return uint4x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint4x3 saturate( const uint4x3& x )
{
	return uint4x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint4x3& lhs, const uint4x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint4x3& lhs, const uint4x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<( const uint4x3& lhs, const uint4x3& rhs )
{
	return bool4x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<=( const uint4x3& lhs, const uint4x3& rhs )
{
	return bool4x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>( const uint4x3& lhs, const uint4x3& rhs )
{
	return bool4x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>=( const uint4x3& lhs, const uint4x3& rhs )
{
	return bool4x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator+( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint4x3 operator+=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x3 operator+( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint4x3 operator+=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator-( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint4x3 operator-=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x3 operator-( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint4x3 operator-=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator*( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint4x3 operator*=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x3 operator*( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint4x3 operator*=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator/( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint4x3 operator/=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x3 operator/( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint4x3 operator/=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint4x3 operator++( uint4x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x3 operator++( uint4x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint4x3 operator--( uint4x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x3 operator--( uint4x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint4x3 operator-( const uint4x3& x )
{
	return uint4x3(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint4x3 operator~( const uint4x3& x )
{
	return uint4x3(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator&( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint4x3 operator&=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x3 operator&( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint4x3 operator&=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator|( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint4x3 operator|=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x3 operator|( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint4x3 operator|=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator^( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint4x3 operator^=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x3 operator^( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint4x3 operator^=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator<<( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint4x3 operator<<=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x3 operator<<( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint4x3 operator<<=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x3 operator>>( const uint4x3& lhs, const uint32_t rhs )
{
	return uint4x3(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint4x3 operator>>=( uint4x3& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x3 operator>>( const uint4x3& lhs, const uint4x3& rhs )
{
	return uint4x3(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint4x3 operator>>=( uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
	mat.rows[3] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 0U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint3x4 transpose( const uint4x3& mat )
{
	return HLML_CONSTRUCT( uint3x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 mul( const uint4x3& lhs, const uint3x4& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];
	uint3 row3 = lhs.rows[3];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	uint3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// uint4x4
// Performs a min function on each row of the matrix.
HLML_INLINE uint4x4 min( const uint4x4& x, const uint4x4& y )
{
	return uint4x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE uint4x4 max( const uint4x4& x, const uint4x4& y )
{
	return uint4x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE uint4x4 clamp( const uint4x4& x, const uint4x4& low, const uint4x4& high )
{
	return uint4x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE uint4x4 saturate( const uint4x4& x )
{
	return uint4x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const uint4x4& lhs, const uint4x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const uint4x4& lhs, const uint4x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<( const uint4x4& lhs, const uint4x4& rhs )
{
	return bool4x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<=( const uint4x4& lhs, const uint4x4& rhs )
{
	return bool4x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>( const uint4x4& lhs, const uint4x4& rhs )
{
	return bool4x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>=( const uint4x4& lhs, const uint4x4& rhs )
{
	return bool4x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator+( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE uint4x4 operator+=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE uint4x4 operator+( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE uint4x4 operator+=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator-( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE uint4x4 operator-=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE uint4x4 operator-( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE uint4x4 operator-=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator*( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE uint4x4 operator*=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE uint4x4 operator*( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE uint4x4 operator*=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator/( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE uint4x4 operator/=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE uint4x4 operator/( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE uint4x4 operator/=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE uint4x4 operator++( uint4x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x4 operator++( uint4x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE uint4x4 operator--( uint4x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE uint4x4 operator--( uint4x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

#if defined( _MSC_VER )
#pragma warning( push, 4 )
#pragma warning( disable : 4146 )
#endif
// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE uint4x4 operator-( const uint4x4& x )
{
	return uint4x4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif
// Returns a copy of the matrix where each component has been bitwise NOT'd.
// pre-fix
HLML_INLINE uint4x4 operator~( const uint4x4& x )
{
	return uint4x4(
		~x[0],
		~x[1],
		~x[2],
		~x[3]
	);
}

// Performs a component-wise bitwise & on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator&( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] & rhs,
		lhs[1] & rhs,
		lhs[2] & rhs,
		lhs[3] & rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise &'d against the scalar.
HLML_INLINE uint4x4 operator&=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise & against the two matrices and returns the result.
HLML_INLINE uint4x4 operator&( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] & rhs[0],
		lhs[1] & rhs[1],
		lhs[2] & rhs[2],
		lhs[3] & rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise &'d against 'rhs'.
HLML_INLINE uint4x4 operator&=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs & rhs );
}

// Performs a component-wise bitwise | on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator|( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] | rhs,
		lhs[1] | rhs,
		lhs[2] | rhs,
		lhs[3] | rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise |'d against the scalar.
HLML_INLINE uint4x4 operator|=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise | against the two matrices and returns the result.
HLML_INLINE uint4x4 operator|( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] | rhs[0],
		lhs[1] | rhs[1],
		lhs[2] | rhs[2],
		lhs[3] | rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise |'d against 'rhs'.
HLML_INLINE uint4x4 operator|=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs | rhs );
}

// Performs a component-wise bitwise ^ on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator^( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] ^ rhs,
		lhs[1] ^ rhs,
		lhs[2] ^ rhs,
		lhs[3] ^ rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise ^'d against the scalar.
HLML_INLINE uint4x4 operator^=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise ^ against the two matrices and returns the result.
HLML_INLINE uint4x4 operator^( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] ^ rhs[0],
		lhs[1] ^ rhs[1],
		lhs[2] ^ rhs[2],
		lhs[3] ^ rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise ^'d against 'rhs'.
HLML_INLINE uint4x4 operator^=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs ^ rhs );
}

// Performs a component-wise bitwise << on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator<<( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] << rhs,
		lhs[1] << rhs,
		lhs[2] << rhs,
		lhs[3] << rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise <<'d against the scalar.
HLML_INLINE uint4x4 operator<<=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise << against the two matrices and returns the result.
HLML_INLINE uint4x4 operator<<( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] << rhs[0],
		lhs[1] << rhs[1],
		lhs[2] << rhs[2],
		lhs[3] << rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise <<'d against 'rhs'.
HLML_INLINE uint4x4 operator<<=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs << rhs );
}

// Performs a component-wise bitwise >> on the matrix by the scalar and returns the result.
HLML_INLINE uint4x4 operator>>( const uint4x4& lhs, const uint32_t rhs )
{
	return uint4x4(
		lhs[0] >> rhs,
		lhs[1] >> rhs,
		lhs[2] >> rhs,
		lhs[3] >> rhs
	);
}

// Returns a copy of 'lhs' where each component has been bitwise >>'d against the scalar.
HLML_INLINE uint4x4 operator>>=( uint4x4& lhs, const uint32_t rhs )
{
	return ( lhs = lhs >> rhs );
}

// Performs a component-wise bitwise >> against the two matrices and returns the result.
HLML_INLINE uint4x4 operator>>( const uint4x4& lhs, const uint4x4& rhs )
{
	return uint4x4(
		lhs[0] >> rhs[0],
		lhs[1] >> rhs[1],
		lhs[2] >> rhs[2],
		lhs[3] >> rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise bitwise >>'d against 'rhs'.
HLML_INLINE uint4x4 operator>>=( uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs = lhs >> rhs );
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( uint4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
	mat.rows[3] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 0U, 1U };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE uint4x4 transpose( const uint4x4& mat )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE uint4x4 mul( const uint4x4& lhs, const uint4x4& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];
	uint4 row3 = lhs.rows[3];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	uint4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( uint4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE uint4 mul( const uint4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ) + ( lhs.w * rhs.rows[3].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ) + ( lhs.w * rhs.rows[3].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z ) + ( lhs.w * rhs.rows[3].z ),
		( lhs.x * rhs.rows[0].w ) + ( lhs.y * rhs.rows[1].w ) + ( lhs.z * rhs.rows[2].w ) + ( lhs.w * rhs.rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE uint4x4 translate( const uint4x4& mat, const uint3& vec )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE uint4x4 scale( const uint4x4& mat, const uint3& scale )
{
	return HLML_CONSTRUCT( uint4x4 )
	{
		mat.rows[0].x * scale.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * scale.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * scale.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

// float2x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x2 sign( const float2x2& x )
{
	return int2x2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float2x2 min( const float2x2& x, const float2x2& y )
{
	return float2x2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float2x2 max( const float2x2& x, const float2x2& y )
{
	return float2x2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float2x2 clamp( const float2x2& x, const float2x2& low, const float2x2& high )
{
	return float2x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float2x2 saturate( const float2x2& x )
{
	return float2x2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float2x2 lerp( const float2x2& lhs, const float2x2& rhs, const float t )
{
	return float2x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float2x2& lhs, const float2x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float2x2& lhs, const float2x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<( const float2x2& lhs, const float2x2& rhs )
{
	return bool2x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<=( const float2x2& lhs, const float2x2& rhs )
{
	return bool2x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>( const float2x2& lhs, const float2x2& rhs )
{
	return bool2x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>=( const float2x2& lhs, const float2x2& rhs )
{
	return bool2x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 operator+( const float2x2& lhs, const float rhs )
{
	return float2x2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float2x2 operator+=( float2x2& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x2 operator+( const float2x2& lhs, const float2x2& rhs )
{
	return float2x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float2x2 operator+=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 operator-( const float2x2& lhs, const float rhs )
{
	return float2x2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float2x2 operator-=( float2x2& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x2 operator-( const float2x2& lhs, const float2x2& rhs )
{
	return float2x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float2x2 operator-=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 operator*( const float2x2& lhs, const float rhs )
{
	return float2x2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float2x2 operator*=( float2x2& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x2 operator*( const float2x2& lhs, const float2x2& rhs )
{
	return float2x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float2x2 operator*=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x2 operator/( const float2x2& lhs, const float rhs )
{
	return float2x2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float2x2 operator/=( float2x2& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x2 operator/( const float2x2& lhs, const float2x2& rhs )
{
	return float2x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float2x2 operator/=( float2x2& lhs, const float2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float2x2 operator++( float2x2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x2 operator++( float2x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float2x2 operator--( float2x2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x2 operator--( float2x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float2x2 operator-( const float2x2& x )
{
	return float2x2(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x2 transpose( const float2x2& mat )
{
	return HLML_CONSTRUCT( float2x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float determinant( const float2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float2x2 inverse( const float2x2& mat )
{
	const float invdet = 1.0f / determinant( mat );
	return HLML_CONSTRUCT( float2x2 )
	{
		 mat.rows[1].y * invdet, -mat.rows[0].y * invdet,
		-mat.rows[1].x * invdet,  mat.rows[0].x * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 mul( const float2x2& lhs, const float2x2& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float2 mul( const float2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y )
	};
}

// float2x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x3 sign( const float2x3& x )
{
	return int2x3(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float2x3 min( const float2x3& x, const float2x3& y )
{
	return float2x3(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float2x3 max( const float2x3& x, const float2x3& y )
{
	return float2x3(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float2x3 clamp( const float2x3& x, const float2x3& low, const float2x3& high )
{
	return float2x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float2x3 saturate( const float2x3& x )
{
	return float2x3(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float2x3 lerp( const float2x3& lhs, const float2x3& rhs, const float t )
{
	return float2x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float2x3& lhs, const float2x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float2x3& lhs, const float2x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<( const float2x3& lhs, const float2x3& rhs )
{
	return bool2x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<=( const float2x3& lhs, const float2x3& rhs )
{
	return bool2x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>( const float2x3& lhs, const float2x3& rhs )
{
	return bool2x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>=( const float2x3& lhs, const float2x3& rhs )
{
	return bool2x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 operator+( const float2x3& lhs, const float rhs )
{
	return float2x3(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float2x3 operator+=( float2x3& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x3 operator+( const float2x3& lhs, const float2x3& rhs )
{
	return float2x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float2x3 operator+=( float2x3& lhs, const float2x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 operator-( const float2x3& lhs, const float rhs )
{
	return float2x3(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float2x3 operator-=( float2x3& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x3 operator-( const float2x3& lhs, const float2x3& rhs )
{
	return float2x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float2x3 operator-=( float2x3& lhs, const float2x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 operator*( const float2x3& lhs, const float rhs )
{
	return float2x3(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float2x3 operator*=( float2x3& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x3 operator*( const float2x3& lhs, const float2x3& rhs )
{
	return float2x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float2x3 operator*=( float2x3& lhs, const float2x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x3 operator/( const float2x3& lhs, const float rhs )
{
	return float2x3(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float2x3 operator/=( float2x3& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x3 operator/( const float2x3& lhs, const float2x3& rhs )
{
	return float2x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float2x3 operator/=( float2x3& lhs, const float2x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float2x3 operator++( float2x3& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x3 operator++( float2x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float2x3 operator--( float2x3& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x3 operator--( float2x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float2x3 operator-( const float2x3& x )
{
	return float2x3(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x2 transpose( const float2x3& mat )
{
	return HLML_CONSTRUCT( float3x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 mul( const float2x3& lhs, const float3x2& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// float2x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x4 sign( const float2x4& x )
{
	return int2x4(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float2x4 min( const float2x4& x, const float2x4& y )
{
	return float2x4(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float2x4 max( const float2x4& x, const float2x4& y )
{
	return float2x4(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float2x4 clamp( const float2x4& x, const float2x4& low, const float2x4& high )
{
	return float2x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float2x4 saturate( const float2x4& x )
{
	return float2x4(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float2x4 lerp( const float2x4& lhs, const float2x4& rhs, const float t )
{
	return float2x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float2x4& lhs, const float2x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float2x4& lhs, const float2x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<( const float2x4& lhs, const float2x4& rhs )
{
	return bool2x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<=( const float2x4& lhs, const float2x4& rhs )
{
	return bool2x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>( const float2x4& lhs, const float2x4& rhs )
{
	return bool2x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>=( const float2x4& lhs, const float2x4& rhs )
{
	return bool2x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 operator+( const float2x4& lhs, const float rhs )
{
	return float2x4(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float2x4 operator+=( float2x4& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float2x4 operator+( const float2x4& lhs, const float2x4& rhs )
{
	return float2x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float2x4 operator+=( float2x4& lhs, const float2x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 operator-( const float2x4& lhs, const float rhs )
{
	return float2x4(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float2x4 operator-=( float2x4& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float2x4 operator-( const float2x4& lhs, const float2x4& rhs )
{
	return float2x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float2x4 operator-=( float2x4& lhs, const float2x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 operator*( const float2x4& lhs, const float rhs )
{
	return float2x4(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float2x4 operator*=( float2x4& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float2x4 operator*( const float2x4& lhs, const float2x4& rhs )
{
	return float2x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float2x4 operator*=( float2x4& lhs, const float2x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float2x4 operator/( const float2x4& lhs, const float rhs )
{
	return float2x4(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float2x4 operator/=( float2x4& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float2x4 operator/( const float2x4& lhs, const float2x4& rhs )
{
	return float2x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float2x4 operator/=( float2x4& lhs, const float2x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float2x4 operator++( float2x4& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x4 operator++( float2x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float2x4 operator--( float2x4& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float2x4 operator--( float2x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float2x4 operator-( const float2x4& x )
{
	return float2x4(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x2 transpose( const float2x4& mat )
{
	return HLML_CONSTRUCT( float4x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float2x2 mul( const float2x4& lhs, const float4x2& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( float2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// float3x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x2 sign( const float3x2& x )
{
	return int3x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float3x2 min( const float3x2& x, const float3x2& y )
{
	return float3x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float3x2 max( const float3x2& x, const float3x2& y )
{
	return float3x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float3x2 clamp( const float3x2& x, const float3x2& low, const float3x2& high )
{
	return float3x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float3x2 saturate( const float3x2& x )
{
	return float3x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float3x2 lerp( const float3x2& lhs, const float3x2& rhs, const float t )
{
	return float3x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float3x2& lhs, const float3x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float3x2& lhs, const float3x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<( const float3x2& lhs, const float3x2& rhs )
{
	return bool3x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<=( const float3x2& lhs, const float3x2& rhs )
{
	return bool3x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>( const float3x2& lhs, const float3x2& rhs )
{
	return bool3x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>=( const float3x2& lhs, const float3x2& rhs )
{
	return bool3x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 operator+( const float3x2& lhs, const float rhs )
{
	return float3x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float3x2 operator+=( float3x2& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x2 operator+( const float3x2& lhs, const float3x2& rhs )
{
	return float3x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float3x2 operator+=( float3x2& lhs, const float3x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 operator-( const float3x2& lhs, const float rhs )
{
	return float3x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float3x2 operator-=( float3x2& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x2 operator-( const float3x2& lhs, const float3x2& rhs )
{
	return float3x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float3x2 operator-=( float3x2& lhs, const float3x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 operator*( const float3x2& lhs, const float rhs )
{
	return float3x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float3x2 operator*=( float3x2& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x2 operator*( const float3x2& lhs, const float3x2& rhs )
{
	return float3x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float3x2 operator*=( float3x2& lhs, const float3x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x2 operator/( const float3x2& lhs, const float rhs )
{
	return float3x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float3x2 operator/=( float3x2& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x2 operator/( const float3x2& lhs, const float3x2& rhs )
{
	return float3x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float3x2 operator/=( float3x2& lhs, const float3x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float3x2 operator++( float3x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x2 operator++( float3x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float3x2 operator--( float3x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x2 operator--( float3x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float3x2 operator-( const float3x2& x )
{
	return float3x2(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat.rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x3 transpose( const float3x2& mat )
{
	return HLML_CONSTRUCT( float2x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 mul( const float3x2& lhs, const float2x3& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// float3x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x3 sign( const float3x3& x )
{
	return int3x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float3x3 min( const float3x3& x, const float3x3& y )
{
	return float3x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float3x3 max( const float3x3& x, const float3x3& y )
{
	return float3x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float3x3 clamp( const float3x3& x, const float3x3& low, const float3x3& high )
{
	return float3x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float3x3 saturate( const float3x3& x )
{
	return float3x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float3x3 lerp( const float3x3& lhs, const float3x3& rhs, const float t )
{
	return float3x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float3x3& lhs, const float3x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float3x3& lhs, const float3x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<( const float3x3& lhs, const float3x3& rhs )
{
	return bool3x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<=( const float3x3& lhs, const float3x3& rhs )
{
	return bool3x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>( const float3x3& lhs, const float3x3& rhs )
{
	return bool3x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>=( const float3x3& lhs, const float3x3& rhs )
{
	return bool3x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 operator+( const float3x3& lhs, const float rhs )
{
	return float3x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float3x3 operator+=( float3x3& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x3 operator+( const float3x3& lhs, const float3x3& rhs )
{
	return float3x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float3x3 operator+=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 operator-( const float3x3& lhs, const float rhs )
{
	return float3x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float3x3 operator-=( float3x3& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x3 operator-( const float3x3& lhs, const float3x3& rhs )
{
	return float3x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float3x3 operator-=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 operator*( const float3x3& lhs, const float rhs )
{
	return float3x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float3x3 operator*=( float3x3& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x3 operator*( const float3x3& lhs, const float3x3& rhs )
{
	return float3x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float3x3 operator*=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x3 operator/( const float3x3& lhs, const float rhs )
{
	return float3x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float3x3 operator/=( float3x3& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x3 operator/( const float3x3& lhs, const float3x3& rhs )
{
	return float3x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float3x3 operator/=( float3x3& lhs, const float3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float3x3 operator++( float3x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x3 operator++( float3x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float3x3 operator--( float3x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x3 operator--( float3x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float3x3 operator-( const float3x3& x )
{
	return float3x3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x3 transpose( const float3x3& mat )
{
	return HLML_CONSTRUCT( float3x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float determinant( const float3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float3x3 inverse( const float3x3& mat )
{
	const float invdet = 1.0f / determinant( mat );
	return HLML_CONSTRUCT( float3x3 )
	{
		 ( mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y ) * invdet,
		-( mat.rows[0].y * mat.rows[2].z - mat.rows[0].z * mat.rows[2].y ) * invdet,
		 ( mat.rows[0].y * mat.rows[1].z - mat.rows[0].z * mat.rows[1].y ) * invdet,

		-( mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[2].z - mat.rows[0].z * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[1].z - mat.rows[0].z * mat.rows[1].x ) * invdet,

		 ( mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[2].y - mat.rows[0].y * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[1].y - mat.rows[0].y * mat.rows[1].x ) * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 mul( const float3x3& lhs, const float3x3& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float3 mul( const float3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z )
	};
}

// float3x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x4 sign( const float3x4& x )
{
	return int3x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float3x4 min( const float3x4& x, const float3x4& y )
{
	return float3x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float3x4 max( const float3x4& x, const float3x4& y )
{
	return float3x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float3x4 clamp( const float3x4& x, const float3x4& low, const float3x4& high )
{
	return float3x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float3x4 saturate( const float3x4& x )
{
	return float3x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float3x4 lerp( const float3x4& lhs, const float3x4& rhs, const float t )
{
	return float3x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float3x4& lhs, const float3x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float3x4& lhs, const float3x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<( const float3x4& lhs, const float3x4& rhs )
{
	return bool3x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<=( const float3x4& lhs, const float3x4& rhs )
{
	return bool3x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>( const float3x4& lhs, const float3x4& rhs )
{
	return bool3x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>=( const float3x4& lhs, const float3x4& rhs )
{
	return bool3x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 operator+( const float3x4& lhs, const float rhs )
{
	return float3x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float3x4 operator+=( float3x4& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float3x4 operator+( const float3x4& lhs, const float3x4& rhs )
{
	return float3x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float3x4 operator+=( float3x4& lhs, const float3x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 operator-( const float3x4& lhs, const float rhs )
{
	return float3x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float3x4 operator-=( float3x4& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float3x4 operator-( const float3x4& lhs, const float3x4& rhs )
{
	return float3x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float3x4 operator-=( float3x4& lhs, const float3x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 operator*( const float3x4& lhs, const float rhs )
{
	return float3x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float3x4 operator*=( float3x4& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float3x4 operator*( const float3x4& lhs, const float3x4& rhs )
{
	return float3x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float3x4 operator*=( float3x4& lhs, const float3x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float3x4 operator/( const float3x4& lhs, const float rhs )
{
	return float3x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float3x4 operator/=( float3x4& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float3x4 operator/( const float3x4& lhs, const float3x4& rhs )
{
	return float3x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float3x4 operator/=( float3x4& lhs, const float3x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float3x4 operator++( float3x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x4 operator++( float3x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float3x4 operator--( float3x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float3x4 operator--( float3x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float3x4 operator-( const float3x4& x )
{
	return float3x4(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x3 transpose( const float3x4& mat )
{
	return HLML_CONSTRUCT( float4x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float3x3 mul( const float3x4& lhs, const float4x3& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( float3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// float4x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x2 sign( const float4x2& x )
{
	return int4x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float4x2 min( const float4x2& x, const float4x2& y )
{
	return float4x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float4x2 max( const float4x2& x, const float4x2& y )
{
	return float4x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float4x2 clamp( const float4x2& x, const float4x2& low, const float4x2& high )
{
	return float4x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float4x2 saturate( const float4x2& x )
{
	return float4x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float4x2 lerp( const float4x2& lhs, const float4x2& rhs, const float t )
{
	return float4x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float4x2& lhs, const float4x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float4x2& lhs, const float4x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<( const float4x2& lhs, const float4x2& rhs )
{
	return bool4x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<=( const float4x2& lhs, const float4x2& rhs )
{
	return bool4x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>( const float4x2& lhs, const float4x2& rhs )
{
	return bool4x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>=( const float4x2& lhs, const float4x2& rhs )
{
	return bool4x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 operator+( const float4x2& lhs, const float rhs )
{
	return float4x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float4x2 operator+=( float4x2& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x2 operator+( const float4x2& lhs, const float4x2& rhs )
{
	return float4x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float4x2 operator+=( float4x2& lhs, const float4x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 operator-( const float4x2& lhs, const float rhs )
{
	return float4x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float4x2 operator-=( float4x2& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x2 operator-( const float4x2& lhs, const float4x2& rhs )
{
	return float4x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float4x2 operator-=( float4x2& lhs, const float4x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 operator*( const float4x2& lhs, const float rhs )
{
	return float4x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float4x2 operator*=( float4x2& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x2 operator*( const float4x2& lhs, const float4x2& rhs )
{
	return float4x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float4x2 operator*=( float4x2& lhs, const float4x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x2 operator/( const float4x2& lhs, const float rhs )
{
	return float4x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float4x2 operator/=( float4x2& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x2 operator/( const float4x2& lhs, const float4x2& rhs )
{
	return float4x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float4x2 operator/=( float4x2& lhs, const float4x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float4x2 operator++( float4x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x2 operator++( float4x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float4x2 operator--( float4x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x2 operator--( float4x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float4x2 operator-( const float4x2& x )
{
	return float4x2(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat.rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
	mat.rows[3] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float2x4 transpose( const float4x2& mat )
{
	return HLML_CONSTRUCT( float2x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 mul( const float4x2& lhs, const float2x4& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];
	float2 row3 = lhs.rows[3];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	float2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// float4x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x3 sign( const float4x3& x )
{
	return int4x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float4x3 min( const float4x3& x, const float4x3& y )
{
	return float4x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float4x3 max( const float4x3& x, const float4x3& y )
{
	return float4x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float4x3 clamp( const float4x3& x, const float4x3& low, const float4x3& high )
{
	return float4x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float4x3 saturate( const float4x3& x )
{
	return float4x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float4x3 lerp( const float4x3& lhs, const float4x3& rhs, const float t )
{
	return float4x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float4x3& lhs, const float4x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float4x3& lhs, const float4x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<( const float4x3& lhs, const float4x3& rhs )
{
	return bool4x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<=( const float4x3& lhs, const float4x3& rhs )
{
	return bool4x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>( const float4x3& lhs, const float4x3& rhs )
{
	return bool4x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>=( const float4x3& lhs, const float4x3& rhs )
{
	return bool4x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 operator+( const float4x3& lhs, const float rhs )
{
	return float4x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float4x3 operator+=( float4x3& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x3 operator+( const float4x3& lhs, const float4x3& rhs )
{
	return float4x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float4x3 operator+=( float4x3& lhs, const float4x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 operator-( const float4x3& lhs, const float rhs )
{
	return float4x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float4x3 operator-=( float4x3& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x3 operator-( const float4x3& lhs, const float4x3& rhs )
{
	return float4x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float4x3 operator-=( float4x3& lhs, const float4x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 operator*( const float4x3& lhs, const float rhs )
{
	return float4x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float4x3 operator*=( float4x3& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x3 operator*( const float4x3& lhs, const float4x3& rhs )
{
	return float4x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float4x3 operator*=( float4x3& lhs, const float4x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x3 operator/( const float4x3& lhs, const float rhs )
{
	return float4x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float4x3 operator/=( float4x3& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x3 operator/( const float4x3& lhs, const float4x3& rhs )
{
	return float4x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float4x3 operator/=( float4x3& lhs, const float4x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float4x3 operator++( float4x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x3 operator++( float4x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float4x3 operator--( float4x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x3 operator--( float4x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float4x3 operator-( const float4x3& x )
{
	return float4x3(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
	mat.rows[3] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 0.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float3x4 transpose( const float4x3& mat )
{
	return HLML_CONSTRUCT( float3x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 mul( const float4x3& lhs, const float3x4& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];
	float3 row3 = lhs.rows[3];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	float3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// float4x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x4 sign( const float4x4& x )
{
	return int4x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE float4x4 min( const float4x4& x, const float4x4& y )
{
	return float4x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE float4x4 max( const float4x4& x, const float4x4& y )
{
	return float4x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE float4x4 clamp( const float4x4& x, const float4x4& low, const float4x4& high )
{
	return float4x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE float4x4 saturate( const float4x4& x )
{
	return float4x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE float4x4 lerp( const float4x4& lhs, const float4x4& rhs, const float t )
{
	return float4x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const float4x4& lhs, const float4x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const float4x4& lhs, const float4x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<( const float4x4& lhs, const float4x4& rhs )
{
	return bool4x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<=( const float4x4& lhs, const float4x4& rhs )
{
	return bool4x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>( const float4x4& lhs, const float4x4& rhs )
{
	return bool4x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>=( const float4x4& lhs, const float4x4& rhs )
{
	return bool4x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 operator+( const float4x4& lhs, const float rhs )
{
	return float4x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE float4x4 operator+=( float4x4& lhs, const float rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE float4x4 operator+( const float4x4& lhs, const float4x4& rhs )
{
	return float4x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE float4x4 operator+=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 operator-( const float4x4& lhs, const float rhs )
{
	return float4x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE float4x4 operator-=( float4x4& lhs, const float rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE float4x4 operator-( const float4x4& lhs, const float4x4& rhs )
{
	return float4x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE float4x4 operator-=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 operator*( const float4x4& lhs, const float rhs )
{
	return float4x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE float4x4 operator*=( float4x4& lhs, const float rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE float4x4 operator*( const float4x4& lhs, const float4x4& rhs )
{
	return float4x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE float4x4 operator*=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE float4x4 operator/( const float4x4& lhs, const float rhs )
{
	return float4x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE float4x4 operator/=( float4x4& lhs, const float rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE float4x4 operator/( const float4x4& lhs, const float4x4& rhs )
{
	return float4x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE float4x4 operator/=( float4x4& lhs, const float4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE float4x4 operator++( float4x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x4 operator++( float4x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE float4x4 operator--( float4x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE float4x4 operator--( float4x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE float4x4 operator-( const float4x4& x )
{
	return float4x4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( float4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
	mat.rows[3] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 0.0f, 1.0f };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE float4x4 transpose( const float4x4& mat )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE float determinant( const float4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	float sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	float sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	float sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	float sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	float sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	float sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	float4 cofactor = HLML_CONSTRUCT( float4 )
	{
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE float4x4 inverse( const float4x4& mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	float coef00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	float coef02 = mat.rows[1].z * mat.rows[3].w - mat.rows[3].z * mat.rows[1].w;
	float coef03 = mat.rows[1].z * mat.rows[2].w - mat.rows[2].z * mat.rows[1].w;

	float coef04 = mat.rows[2].y * mat.rows[3].w - mat.rows[3].y * mat.rows[2].w;
	float coef06 = mat.rows[1].y * mat.rows[3].w - mat.rows[3].y * mat.rows[1].w;
	float coef07 = mat.rows[1].y * mat.rows[2].w - mat.rows[2].y * mat.rows[1].w;

	float coef08 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	float coef10 = mat.rows[1].y * mat.rows[3].z - mat.rows[3].y * mat.rows[1].z;
	float coef11 = mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z;

	float coef12 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	float coef14 = mat.rows[1].x * mat.rows[3].w - mat.rows[3].x * mat.rows[1].w;
	float coef15 = mat.rows[1].x * mat.rows[2].w - mat.rows[2].x * mat.rows[1].w;

	float coef16 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	float coef18 = mat.rows[1].x * mat.rows[3].z - mat.rows[3].x * mat.rows[1].z;
	float coef19 = mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z;

	float coef20 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;
	float coef22 = mat.rows[1].x * mat.rows[3].y - mat.rows[3].x * mat.rows[1].y;
	float coef23 = mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y;

	float4 fac0 = { coef00, coef00, coef02, coef03 };
	float4 fac1 = { coef04, coef04, coef06, coef07 };
	float4 fac2 = { coef08, coef08, coef10, coef11 };
	float4 fac3 = { coef12, coef12, coef14, coef15 };
	float4 fac4 = { coef16, coef16, coef18, coef19 };
	float4 fac5 = { coef20, coef20, coef22, coef23 };

	float4 vec0 = { mat.rows[1].x, mat.rows[0].x, mat.rows[0].x, mat.rows[0].x };
	float4 vec1 = { mat.rows[1].y, mat.rows[0].y, mat.rows[0].y, mat.rows[0].y };
	float4 vec2 = { mat.rows[1].z, mat.rows[0].z, mat.rows[0].z, mat.rows[0].z };
	float4 vec3 = { mat.rows[1].w, mat.rows[0].w, mat.rows[0].w, mat.rows[0].w };

	float4 inv0 = vec1 * fac0 - vec2 * fac1 + vec3 * fac2;
	float4 inv1 = vec0 * fac0 - vec2 * fac3 + vec3 * fac4;
	float4 inv2 = vec0 * fac1 - vec1 * fac3 + vec3 * fac5;
	float4 inv3 = vec0 * fac2 - vec1 * fac4 + vec2 * fac5;

	float4 sign0 = float4(  1, -1,  1, -1 );
	float4 sign1 = float4( -1,  1, -1,  1 );

	float4x4 result = float4x4(
		inv0 * sign0,
		inv1 * sign1,
		inv2 * sign0,
		inv3 * sign1
	);

	float4 row0 = float4( result.rows[0][0], result.rows[1][0], result.rows[2][0], result.rows[3][0] );
	float4 dot0 = mat.rows[0] * row0;

	const float dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const float invdet = 1.0f / dot1;

	return result * invdet;
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE float4x4 mul( const float4x4& lhs, const float4x4& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];
	float4 row3 = lhs.rows[3];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	float4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( float4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE float4 mul( const float4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ) + ( lhs.w * rhs.rows[3].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ) + ( lhs.w * rhs.rows[3].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z ) + ( lhs.w * rhs.rows[3].z ),
		( lhs.x * rhs.rows[0].w ) + ( lhs.y * rhs.rows[1].w ) + ( lhs.z * rhs.rows[2].w ) + ( lhs.w * rhs.rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE float4x4 translate( const float4x4& mat, const float3& vec )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

// Rotates the matrix by the given axis-angle (in radians) and returns the result.
HLML_INLINE float4x4 rotate( const float4x4& mat, const float rad, const float3& axis )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 u = normalized( axis );
	float ic = 1.0f - c;

	float4x4 rotation = mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return mul( mat, rotation );
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE float4x4 scale( const float4x4& mat, const float3& scale )
{
	return HLML_CONSTRUCT( float4x4 )
	{
		mat.rows[0].x * scale.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * scale.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * scale.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE float4x4 ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip space range: zero-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE float4x4 ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE float4x4 ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip space range: zero-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE float4x4 ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 )
	{
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE float4x4 perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: zero-to-one
	const float far_minus_near = zfar - znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE float4x4 perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE float4x4 perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: zero-to-one
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE float4x4 perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 )
	{
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, -far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

// Returns a left-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE float4x4 look_at_lh( const float3& eye, const float3& target, const float3& up )
{
	// left handed
	const float3 forward = normalized( target - eye );
	const float3 up_cross_forward = cross( up, forward );
	const float3 right = normalized( up_cross_forward );
	const float3 up1 = cross( forward, right );

	return HLML_CONSTRUCT( float4x4 )
	{
		right.x,   right.y,   right.z,   -dot( right, eye ),
		up1.x,     up1.y,     up1.z,     -dot( up1, eye ),
		forward.x, forward.y, forward.z, -dot( forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// Returns a right-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE float4x4 look_at_rh( const float3& eye, const float3& target, const float3& up )
{
	// right handed
	const float3 forward = normalized( target - eye );
	const float3 forward_cross_up = cross( forward, up );
	const float3 right = normalized( forward_cross_up );
	const float3 up1 = cross( right, forward );

	return HLML_CONSTRUCT( float4x4 )
	{
		 right.x,    right.y,    right.z,   -dot( right, eye ),
		 up1.x,      up1.y,      up1.z,     -dot( up1, eye ),
		-forward.x, -forward.y, -forward.z,  dot( forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

// double2x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x2 sign( const double2x2& x )
{
	return int2x2(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double2x2 min( const double2x2& x, const double2x2& y )
{
	return double2x2(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double2x2 max( const double2x2& x, const double2x2& y )
{
	return double2x2(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double2x2 clamp( const double2x2& x, const double2x2& low, const double2x2& high )
{
	return double2x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double2x2 saturate( const double2x2& x )
{
	return double2x2(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double2x2 lerp( const double2x2& lhs, const double2x2& rhs, const double t )
{
	return double2x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double2x2& lhs, const double2x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double2x2& lhs, const double2x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<( const double2x2& lhs, const double2x2& rhs )
{
	return bool2x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator<=( const double2x2& lhs, const double2x2& rhs )
{
	return bool2x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>( const double2x2& lhs, const double2x2& rhs )
{
	return bool2x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x2 operator>=( const double2x2& lhs, const double2x2& rhs )
{
	return bool2x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 operator+( const double2x2& lhs, const double rhs )
{
	return double2x2(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double2x2 operator+=( double2x2& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x2 operator+( const double2x2& lhs, const double2x2& rhs )
{
	return double2x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double2x2 operator+=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 operator-( const double2x2& lhs, const double rhs )
{
	return double2x2(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double2x2 operator-=( double2x2& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x2 operator-( const double2x2& lhs, const double2x2& rhs )
{
	return double2x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double2x2 operator-=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 operator*( const double2x2& lhs, const double rhs )
{
	return double2x2(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double2x2 operator*=( double2x2& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x2 operator*( const double2x2& lhs, const double2x2& rhs )
{
	return double2x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double2x2 operator*=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x2 operator/( const double2x2& lhs, const double rhs )
{
	return double2x2(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double2x2 operator/=( double2x2& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x2 operator/( const double2x2& lhs, const double2x2& rhs )
{
	return double2x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double2x2 operator/=( double2x2& lhs, const double2x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double2x2 operator++( double2x2& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x2 operator++( double2x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double2x2 operator--( double2x2& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x2 operator--( double2x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double2x2 operator-( const double2x2& x )
{
	return double2x2(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x2 transpose( const double2x2& mat )
{
	return HLML_CONSTRUCT( double2x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double determinant( const double2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double2x2 inverse( const double2x2& mat )
{
	const double invdet = 1.0 / determinant( mat );
	return HLML_CONSTRUCT( double2x2 )
	{
		 mat.rows[1].y * invdet, -mat.rows[0].y * invdet,
		-mat.rows[1].x * invdet,  mat.rows[0].x * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 mul( const double2x2& lhs, const double2x2& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double2 mul( const double2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y )
	};
}

// double2x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x3 sign( const double2x3& x )
{
	return int2x3(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double2x3 min( const double2x3& x, const double2x3& y )
{
	return double2x3(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double2x3 max( const double2x3& x, const double2x3& y )
{
	return double2x3(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double2x3 clamp( const double2x3& x, const double2x3& low, const double2x3& high )
{
	return double2x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double2x3 saturate( const double2x3& x )
{
	return double2x3(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double2x3 lerp( const double2x3& lhs, const double2x3& rhs, const double t )
{
	return double2x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double2x3& lhs, const double2x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double2x3& lhs, const double2x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<( const double2x3& lhs, const double2x3& rhs )
{
	return bool2x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator<=( const double2x3& lhs, const double2x3& rhs )
{
	return bool2x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>( const double2x3& lhs, const double2x3& rhs )
{
	return bool2x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x3 operator>=( const double2x3& lhs, const double2x3& rhs )
{
	return bool2x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 operator+( const double2x3& lhs, const double rhs )
{
	return double2x3(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double2x3 operator+=( double2x3& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x3 operator+( const double2x3& lhs, const double2x3& rhs )
{
	return double2x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double2x3 operator+=( double2x3& lhs, const double2x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 operator-( const double2x3& lhs, const double rhs )
{
	return double2x3(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double2x3 operator-=( double2x3& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x3 operator-( const double2x3& lhs, const double2x3& rhs )
{
	return double2x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double2x3 operator-=( double2x3& lhs, const double2x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 operator*( const double2x3& lhs, const double rhs )
{
	return double2x3(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double2x3 operator*=( double2x3& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x3 operator*( const double2x3& lhs, const double2x3& rhs )
{
	return double2x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double2x3 operator*=( double2x3& lhs, const double2x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x3 operator/( const double2x3& lhs, const double rhs )
{
	return double2x3(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double2x3 operator/=( double2x3& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x3 operator/( const double2x3& lhs, const double2x3& rhs )
{
	return double2x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double2x3 operator/=( double2x3& lhs, const double2x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double2x3 operator++( double2x3& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x3 operator++( double2x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double2x3 operator--( double2x3& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x3 operator--( double2x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double2x3 operator-( const double2x3& x )
{
	return double2x3(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x2 transpose( const double2x3& mat )
{
	return HLML_CONSTRUCT( double3x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 mul( const double2x3& lhs, const double3x2& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

// double2x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int2x4 sign( const double2x4& x )
{
	return int2x4(
		sign( x[0] ),
		sign( x[1] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double2x4 min( const double2x4& x, const double2x4& y )
{
	return double2x4(
		min( x[0], y[0] ),
		min( x[1], y[1] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double2x4 max( const double2x4& x, const double2x4& y )
{
	return double2x4(
		max( x[0], y[0] ),
		max( x[1], y[1] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double2x4 clamp( const double2x4& x, const double2x4& low, const double2x4& high )
{
	return double2x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double2x4 saturate( const double2x4& x )
{
	return double2x4(
		saturate( x[0] ),
		saturate( x[1] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double2x4 lerp( const double2x4& lhs, const double2x4& rhs, const double t )
{
	return double2x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double2x4& lhs, const double2x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double2x4& lhs, const double2x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<( const double2x4& lhs, const double2x4& rhs )
{
	return bool2x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator<=( const double2x4& lhs, const double2x4& rhs )
{
	return bool2x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>( const double2x4& lhs, const double2x4& rhs )
{
	return bool2x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool2x4 operator>=( const double2x4& lhs, const double2x4& rhs )
{
	return bool2x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 operator+( const double2x4& lhs, const double rhs )
{
	return double2x4(
		lhs[0] + rhs,
		lhs[1] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double2x4 operator+=( double2x4& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double2x4 operator+( const double2x4& lhs, const double2x4& rhs )
{
	return double2x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double2x4 operator+=( double2x4& lhs, const double2x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 operator-( const double2x4& lhs, const double rhs )
{
	return double2x4(
		lhs[0] - rhs,
		lhs[1] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double2x4 operator-=( double2x4& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double2x4 operator-( const double2x4& lhs, const double2x4& rhs )
{
	return double2x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double2x4 operator-=( double2x4& lhs, const double2x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 operator*( const double2x4& lhs, const double rhs )
{
	return double2x4(
		lhs[0] * rhs,
		lhs[1] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double2x4 operator*=( double2x4& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double2x4 operator*( const double2x4& lhs, const double2x4& rhs )
{
	return double2x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double2x4 operator*=( double2x4& lhs, const double2x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double2x4 operator/( const double2x4& lhs, const double rhs )
{
	return double2x4(
		lhs[0] / rhs,
		lhs[1] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double2x4 operator/=( double2x4& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double2x4 operator/( const double2x4& lhs, const double2x4& rhs )
{
	return double2x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double2x4 operator/=( double2x4& lhs, const double2x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double2x4 operator++( double2x4& x )
{
	++x[0];
	++x[1];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x4 operator++( double2x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double2x4 operator--( double2x4& x )
{
	--x[0];
	--x[1];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double2x4 operator--( double2x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double2x4 operator-( const double2x4& x )
{
	return double2x4(
		-x[0],
		-x[1]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x2 transpose( const double2x4& mat )
{
	return HLML_CONSTRUCT( double4x2 )
	{
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double2x2 mul( const double2x4& lhs, const double4x2& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( double2x2 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

// double3x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x2 sign( const double3x2& x )
{
	return int3x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double3x2 min( const double3x2& x, const double3x2& y )
{
	return double3x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double3x2 max( const double3x2& x, const double3x2& y )
{
	return double3x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double3x2 clamp( const double3x2& x, const double3x2& low, const double3x2& high )
{
	return double3x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double3x2 saturate( const double3x2& x )
{
	return double3x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double3x2 lerp( const double3x2& lhs, const double3x2& rhs, const double t )
{
	return double3x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double3x2& lhs, const double3x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double3x2& lhs, const double3x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<( const double3x2& lhs, const double3x2& rhs )
{
	return bool3x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator<=( const double3x2& lhs, const double3x2& rhs )
{
	return bool3x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>( const double3x2& lhs, const double3x2& rhs )
{
	return bool3x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x2 operator>=( const double3x2& lhs, const double3x2& rhs )
{
	return bool3x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 operator+( const double3x2& lhs, const double rhs )
{
	return double3x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double3x2 operator+=( double3x2& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x2 operator+( const double3x2& lhs, const double3x2& rhs )
{
	return double3x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double3x2 operator+=( double3x2& lhs, const double3x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 operator-( const double3x2& lhs, const double rhs )
{
	return double3x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double3x2 operator-=( double3x2& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x2 operator-( const double3x2& lhs, const double3x2& rhs )
{
	return double3x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double3x2 operator-=( double3x2& lhs, const double3x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 operator*( const double3x2& lhs, const double rhs )
{
	return double3x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double3x2 operator*=( double3x2& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x2 operator*( const double3x2& lhs, const double3x2& rhs )
{
	return double3x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double3x2 operator*=( double3x2& lhs, const double3x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x2 operator/( const double3x2& lhs, const double rhs )
{
	return double3x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double3x2 operator/=( double3x2& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x2 operator/( const double3x2& lhs, const double3x2& rhs )
{
	return double3x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double3x2 operator/=( double3x2& lhs, const double3x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double3x2 operator++( double3x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x2 operator++( double3x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double3x2 operator--( double3x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x2 operator--( double3x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double3x2 operator-( const double3x2& x )
{
	return double3x2(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat.rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x3 transpose( const double3x2& mat )
{
	return HLML_CONSTRUCT( double2x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 mul( const double3x2& lhs, const double2x3& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

// double3x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x3 sign( const double3x3& x )
{
	return int3x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double3x3 min( const double3x3& x, const double3x3& y )
{
	return double3x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double3x3 max( const double3x3& x, const double3x3& y )
{
	return double3x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double3x3 clamp( const double3x3& x, const double3x3& low, const double3x3& high )
{
	return double3x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double3x3 saturate( const double3x3& x )
{
	return double3x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double3x3 lerp( const double3x3& lhs, const double3x3& rhs, const double t )
{
	return double3x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double3x3& lhs, const double3x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double3x3& lhs, const double3x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<( const double3x3& lhs, const double3x3& rhs )
{
	return bool3x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator<=( const double3x3& lhs, const double3x3& rhs )
{
	return bool3x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>( const double3x3& lhs, const double3x3& rhs )
{
	return bool3x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x3 operator>=( const double3x3& lhs, const double3x3& rhs )
{
	return bool3x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 operator+( const double3x3& lhs, const double rhs )
{
	return double3x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double3x3 operator+=( double3x3& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x3 operator+( const double3x3& lhs, const double3x3& rhs )
{
	return double3x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double3x3 operator+=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 operator-( const double3x3& lhs, const double rhs )
{
	return double3x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double3x3 operator-=( double3x3& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x3 operator-( const double3x3& lhs, const double3x3& rhs )
{
	return double3x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double3x3 operator-=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 operator*( const double3x3& lhs, const double rhs )
{
	return double3x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double3x3 operator*=( double3x3& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x3 operator*( const double3x3& lhs, const double3x3& rhs )
{
	return double3x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double3x3 operator*=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x3 operator/( const double3x3& lhs, const double rhs )
{
	return double3x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double3x3 operator/=( double3x3& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x3 operator/( const double3x3& lhs, const double3x3& rhs )
{
	return double3x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double3x3 operator/=( double3x3& lhs, const double3x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double3x3 operator++( double3x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x3 operator++( double3x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double3x3 operator--( double3x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x3 operator--( double3x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double3x3 operator-( const double3x3& x )
{
	return double3x3(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x3 transpose( const double3x3& mat )
{
	return HLML_CONSTRUCT( double3x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double determinant( const double3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double3x3 inverse( const double3x3& mat )
{
	const double invdet = 1.0 / determinant( mat );
	return HLML_CONSTRUCT( double3x3 )
	{
		 ( mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y ) * invdet,
		-( mat.rows[0].y * mat.rows[2].z - mat.rows[0].z * mat.rows[2].y ) * invdet,
		 ( mat.rows[0].y * mat.rows[1].z - mat.rows[0].z * mat.rows[1].y ) * invdet,

		-( mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[2].z - mat.rows[0].z * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[1].z - mat.rows[0].z * mat.rows[1].x ) * invdet,

		 ( mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[2].y - mat.rows[0].y * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[1].y - mat.rows[0].y * mat.rows[1].x ) * invdet
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 mul( const double3x3& lhs, const double3x3& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double3 mul( const double3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z )
	};
}

// double3x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int3x4 sign( const double3x4& x )
{
	return int3x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double3x4 min( const double3x4& x, const double3x4& y )
{
	return double3x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double3x4 max( const double3x4& x, const double3x4& y )
{
	return double3x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double3x4 clamp( const double3x4& x, const double3x4& low, const double3x4& high )
{
	return double3x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double3x4 saturate( const double3x4& x )
{
	return double3x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double3x4 lerp( const double3x4& lhs, const double3x4& rhs, const double t )
{
	return double3x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double3x4& lhs, const double3x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double3x4& lhs, const double3x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<( const double3x4& lhs, const double3x4& rhs )
{
	return bool3x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator<=( const double3x4& lhs, const double3x4& rhs )
{
	return bool3x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>( const double3x4& lhs, const double3x4& rhs )
{
	return bool3x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool3x4 operator>=( const double3x4& lhs, const double3x4& rhs )
{
	return bool3x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 operator+( const double3x4& lhs, const double rhs )
{
	return double3x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double3x4 operator+=( double3x4& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double3x4 operator+( const double3x4& lhs, const double3x4& rhs )
{
	return double3x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double3x4 operator+=( double3x4& lhs, const double3x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 operator-( const double3x4& lhs, const double rhs )
{
	return double3x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double3x4 operator-=( double3x4& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double3x4 operator-( const double3x4& lhs, const double3x4& rhs )
{
	return double3x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double3x4 operator-=( double3x4& lhs, const double3x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 operator*( const double3x4& lhs, const double rhs )
{
	return double3x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double3x4 operator*=( double3x4& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double3x4 operator*( const double3x4& lhs, const double3x4& rhs )
{
	return double3x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double3x4 operator*=( double3x4& lhs, const double3x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double3x4 operator/( const double3x4& lhs, const double rhs )
{
	return double3x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double3x4 operator/=( double3x4& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double3x4 operator/( const double3x4& lhs, const double3x4& rhs )
{
	return double3x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double3x4 operator/=( double3x4& lhs, const double3x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double3x4 operator++( double3x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x4 operator++( double3x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double3x4 operator--( double3x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double3x4 operator--( double3x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double3x4 operator-( const double3x4& x )
{
	return double3x4(
		-x[0],
		-x[1],
		-x[2]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x3 transpose( const double3x4& mat )
{
	return HLML_CONSTRUCT( double4x3 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double3x3 mul( const double3x4& lhs, const double4x3& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( double3x3 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

// double4x2
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x2 sign( const double4x2& x )
{
	return int4x2(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double4x2 min( const double4x2& x, const double4x2& y )
{
	return double4x2(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double4x2 max( const double4x2& x, const double4x2& y )
{
	return double4x2(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double4x2 clamp( const double4x2& x, const double4x2& low, const double4x2& high )
{
	return double4x2(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double4x2 saturate( const double4x2& x )
{
	return double4x2(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double4x2 lerp( const double4x2& lhs, const double4x2& rhs, const double t )
{
	return double4x2(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double4x2& lhs, const double4x2& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double4x2& lhs, const double4x2& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<( const double4x2& lhs, const double4x2& rhs )
{
	return bool4x2(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator<=( const double4x2& lhs, const double4x2& rhs )
{
	return bool4x2(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>( const double4x2& lhs, const double4x2& rhs )
{
	return bool4x2(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x2 operator>=( const double4x2& lhs, const double4x2& rhs )
{
	return bool4x2(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 operator+( const double4x2& lhs, const double rhs )
{
	return double4x2(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double4x2 operator+=( double4x2& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x2 operator+( const double4x2& lhs, const double4x2& rhs )
{
	return double4x2(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double4x2 operator+=( double4x2& lhs, const double4x2& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 operator-( const double4x2& lhs, const double rhs )
{
	return double4x2(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double4x2 operator-=( double4x2& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x2 operator-( const double4x2& lhs, const double4x2& rhs )
{
	return double4x2(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double4x2 operator-=( double4x2& lhs, const double4x2& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 operator*( const double4x2& lhs, const double rhs )
{
	return double4x2(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double4x2 operator*=( double4x2& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x2 operator*( const double4x2& lhs, const double4x2& rhs )
{
	return double4x2(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double4x2 operator*=( double4x2& lhs, const double4x2& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x2 operator/( const double4x2& lhs, const double rhs )
{
	return double4x2(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double4x2 operator/=( double4x2& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x2 operator/( const double4x2& lhs, const double4x2& rhs )
{
	return double4x2(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double4x2 operator/=( double4x2& lhs, const double4x2& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double4x2 operator++( double4x2& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x2 operator++( double4x2& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double4x2 operator--( double4x2& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x2 operator--( double4x2& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double4x2 operator-( const double4x2& x )
{
	return double4x2(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat.rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
	mat.rows[3] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double2x4 transpose( const double4x2& mat )
{
	return HLML_CONSTRUCT( double2x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 mul( const double4x2& lhs, const double2x4& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];
	double2 row3 = lhs.rows[3];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	double2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

// double4x3
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x3 sign( const double4x3& x )
{
	return int4x3(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double4x3 min( const double4x3& x, const double4x3& y )
{
	return double4x3(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double4x3 max( const double4x3& x, const double4x3& y )
{
	return double4x3(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double4x3 clamp( const double4x3& x, const double4x3& low, const double4x3& high )
{
	return double4x3(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double4x3 saturate( const double4x3& x )
{
	return double4x3(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double4x3 lerp( const double4x3& lhs, const double4x3& rhs, const double t )
{
	return double4x3(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double4x3& lhs, const double4x3& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double4x3& lhs, const double4x3& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<( const double4x3& lhs, const double4x3& rhs )
{
	return bool4x3(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator<=( const double4x3& lhs, const double4x3& rhs )
{
	return bool4x3(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>( const double4x3& lhs, const double4x3& rhs )
{
	return bool4x3(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x3 operator>=( const double4x3& lhs, const double4x3& rhs )
{
	return bool4x3(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 operator+( const double4x3& lhs, const double rhs )
{
	return double4x3(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double4x3 operator+=( double4x3& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x3 operator+( const double4x3& lhs, const double4x3& rhs )
{
	return double4x3(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double4x3 operator+=( double4x3& lhs, const double4x3& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 operator-( const double4x3& lhs, const double rhs )
{
	return double4x3(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double4x3 operator-=( double4x3& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x3 operator-( const double4x3& lhs, const double4x3& rhs )
{
	return double4x3(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double4x3 operator-=( double4x3& lhs, const double4x3& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 operator*( const double4x3& lhs, const double rhs )
{
	return double4x3(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double4x3 operator*=( double4x3& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x3 operator*( const double4x3& lhs, const double4x3& rhs )
{
	return double4x3(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double4x3 operator*=( double4x3& lhs, const double4x3& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x3 operator/( const double4x3& lhs, const double rhs )
{
	return double4x3(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double4x3 operator/=( double4x3& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x3 operator/( const double4x3& lhs, const double4x3& rhs )
{
	return double4x3(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double4x3 operator/=( double4x3& lhs, const double4x3& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double4x3 operator++( double4x3& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x3 operator++( double4x3& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double4x3 operator--( double4x3& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x3 operator--( double4x3& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double4x3 operator-( const double4x3& x )
{
	return double4x3(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
	mat.rows[3] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 0.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double3x4 transpose( const double4x3& mat )
{
	return HLML_CONSTRUCT( double3x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 mul( const double4x3& lhs, const double3x4& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];
	double3 row3 = lhs.rows[3];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	double3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

// double4x4
// Performs a sign function on each row of the matrix.
HLML_INLINE int4x4 sign( const double4x4& x )
{
	return int4x4(
		sign( x[0] ),
		sign( x[1] ),
		sign( x[2] ),
		sign( x[3] )
	);
}

// Performs a min function on each row of the matrix.
HLML_INLINE double4x4 min( const double4x4& x, const double4x4& y )
{
	return double4x4(
		min( x[0], y[0] ),
		min( x[1], y[1] ),
		min( x[2], y[2] ),
		min( x[3], y[3] )
	);
}

// Performs a max function on each row of the matrix.
HLML_INLINE double4x4 max( const double4x4& x, const double4x4& y )
{
	return double4x4(
		max( x[0], y[0] ),
		max( x[1], y[1] ),
		max( x[2], y[2] ),
		max( x[3], y[3] )
	);
}

// Performs a clamp function on each row of the matrix.
HLML_INLINE double4x4 clamp( const double4x4& x, const double4x4& low, const double4x4& high )
{
	return double4x4(
		clamp( x[0], low[0], high[0] ),
		clamp( x[1], low[1], high[1] ),
		clamp( x[2], low[2], high[2] ),
		clamp( x[3], low[3], high[3] )
	);
}

// Performs a saturate function on each row of the matrix.
HLML_INLINE double4x4 saturate( const double4x4& x )
{
	return double4x4(
		saturate( x[0] ),
		saturate( x[1] ),
		saturate( x[2] ),
		saturate( x[3] )
	);
}

// Performs a lerp function on each row of the matrix.
HLML_INLINE double4x4 lerp( const double4x4& lhs, const double4x4& rhs, const double t )
{
	return double4x4(
		lerp( lhs[0], rhs[0], t ),
		lerp( lhs[1], rhs[1], t ),
		lerp( lhs[2], rhs[2], t ),
		lerp( lhs[3], rhs[3], t )
	);
}

// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator==( const double4x4& lhs, const double4x4& rhs )
{
	return
		lhs[0] == rhs[0] &&
		lhs[1] == rhs[1] &&
		lhs[2] == rhs[2] &&
		lhs[3] == rhs[3];
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool operator!=( const double4x4& lhs, const double4x4& rhs )
{
	return !( lhs == rhs );
}

// Performs a component-wise '<' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<( const double4x4& lhs, const double4x4& rhs )
{
	return bool4x4(
		lhs[0] < rhs[0],
		lhs[1] < rhs[1],
		lhs[2] < rhs[2],
		lhs[3] < rhs[3]
	);
}

// Performs a component-wise '<=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator<=( const double4x4& lhs, const double4x4& rhs )
{
	return bool4x4(
		lhs[0] <= rhs[0],
		lhs[1] <= rhs[1],
		lhs[2] <= rhs[2],
		lhs[3] <= rhs[3]
	);
}

// Performs a component-wise '>' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>( const double4x4& lhs, const double4x4& rhs )
{
	return bool4x4(
		lhs[0] > rhs[0],
		lhs[1] > rhs[1],
		lhs[2] > rhs[2],
		lhs[3] > rhs[3]
	);
}

// Performs a component-wise '>=' check against the two matrices and returns the result.
HLML_INLINE bool4x4 operator>=( const double4x4& lhs, const double4x4& rhs )
{
	return bool4x4(
		lhs[0] >= rhs[0],
		lhs[1] >= rhs[1],
		lhs[2] >= rhs[2],
		lhs[3] >= rhs[3]
	);
}

// Performs a component-wise + on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 operator+( const double4x4& lhs, const double rhs )
{
	return double4x4(
		lhs[0] + rhs,
		lhs[1] + rhs,
		lhs[2] + rhs,
		lhs[3] + rhs
	);
}

// Returns a copy of 'lhs' where each component has been +'d against the scalar.
HLML_INLINE double4x4 operator+=( double4x4& lhs, const double rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise + against the two matrices and returns the result.
HLML_INLINE double4x4 operator+( const double4x4& lhs, const double4x4& rhs )
{
	return double4x4(
		lhs[0] + rhs[0],
		lhs[1] + rhs[1],
		lhs[2] + rhs[2],
		lhs[3] + rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise +'d against 'rhs'.
HLML_INLINE double4x4 operator+=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs + rhs );
}

// Performs a component-wise - on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 operator-( const double4x4& lhs, const double rhs )
{
	return double4x4(
		lhs[0] - rhs,
		lhs[1] - rhs,
		lhs[2] - rhs,
		lhs[3] - rhs
	);
}

// Returns a copy of 'lhs' where each component has been -'d against the scalar.
HLML_INLINE double4x4 operator-=( double4x4& lhs, const double rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise - against the two matrices and returns the result.
HLML_INLINE double4x4 operator-( const double4x4& lhs, const double4x4& rhs )
{
	return double4x4(
		lhs[0] - rhs[0],
		lhs[1] - rhs[1],
		lhs[2] - rhs[2],
		lhs[3] - rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise -'d against 'rhs'.
HLML_INLINE double4x4 operator-=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs - rhs );
}

// Performs a component-wise * on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 operator*( const double4x4& lhs, const double rhs )
{
	return double4x4(
		lhs[0] * rhs,
		lhs[1] * rhs,
		lhs[2] * rhs,
		lhs[3] * rhs
	);
}

// Returns a copy of 'lhs' where each component has been *'d against the scalar.
HLML_INLINE double4x4 operator*=( double4x4& lhs, const double rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise * against the two matrices and returns the result.
HLML_INLINE double4x4 operator*( const double4x4& lhs, const double4x4& rhs )
{
	return double4x4(
		lhs[0] * rhs[0],
		lhs[1] * rhs[1],
		lhs[2] * rhs[2],
		lhs[3] * rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise *'d against 'rhs'.
HLML_INLINE double4x4 operator*=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs * rhs );
}

// Performs a component-wise / on the matrix by the scalar and returns the result.
HLML_INLINE double4x4 operator/( const double4x4& lhs, const double rhs )
{
	return double4x4(
		lhs[0] / rhs,
		lhs[1] / rhs,
		lhs[2] / rhs,
		lhs[3] / rhs
	);
}

// Returns a copy of 'lhs' where each component has been /'d against the scalar.
HLML_INLINE double4x4 operator/=( double4x4& lhs, const double rhs )
{
	return ( lhs = lhs / rhs );
}

// Performs a component-wise / against the two matrices and returns the result.
HLML_INLINE double4x4 operator/( const double4x4& lhs, const double4x4& rhs )
{
	return double4x4(
		lhs[0] / rhs[0],
		lhs[1] / rhs[1],
		lhs[2] / rhs[2],
		lhs[3] / rhs[3]
	);
}

// Returns a copy of 'lhs' that has been component-wise /'d against 'rhs'.
HLML_INLINE double4x4 operator/=( double4x4& lhs, const double4x4& rhs )
{
	return ( lhs = lhs / rhs );
}

// ++s each component of the matrix and returns the result.
HLML_INLINE double4x4 operator++( double4x4& x )
{
	++x[0];
	++x[1];
	++x[2];
	++x[3];
	return x;
}

// ++s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x4 operator++( double4x4& x, const int32_t )
{
	x[0]++;
	x[1]++;
	x[2]++;
	x[3]++;
	return x;
}

// --s each component of the matrix and returns the result.
HLML_INLINE double4x4 operator--( double4x4& x )
{
	--x[0];
	--x[1];
	--x[2];
	--x[3];
	return x;
}

// --s each component of the matrix and returns the result.
// post-fix
HLML_INLINE double4x4 operator--( double4x4& x, const int32_t )
{
	x[0]--;
	x[1]--;
	x[2]--;
	x[3]--;
	return x;
}

// Returns a copy of the matrix that has been negated.
// pre-fix
HLML_INLINE double4x4 operator-( const double4x4& x )
{
	return double4x4(
		-x[0],
		-x[1],
		-x[2],
		-x[3]
	);
}

// Sets the matrix to an identity matrix.
HLML_INLINE void identity( double4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
	mat.rows[3] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 0.0, 1.0 };
}

// Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
HLML_INLINE double4x4 transpose( const double4x4& mat )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

// Returns the determinant of the matrix.
HLML_INLINE double determinant( const double4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	double sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	double sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	double sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	double sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	double sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	double sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	double4 cofactor = HLML_CONSTRUCT( double4 )
	{
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

// Returns a copy of the matrix that is inversed.
// This is only applicable for square matrices.
HLML_INLINE double4x4 inverse( const double4x4& mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	double coef00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	double coef02 = mat.rows[1].z * mat.rows[3].w - mat.rows[3].z * mat.rows[1].w;
	double coef03 = mat.rows[1].z * mat.rows[2].w - mat.rows[2].z * mat.rows[1].w;

	double coef04 = mat.rows[2].y * mat.rows[3].w - mat.rows[3].y * mat.rows[2].w;
	double coef06 = mat.rows[1].y * mat.rows[3].w - mat.rows[3].y * mat.rows[1].w;
	double coef07 = mat.rows[1].y * mat.rows[2].w - mat.rows[2].y * mat.rows[1].w;

	double coef08 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	double coef10 = mat.rows[1].y * mat.rows[3].z - mat.rows[3].y * mat.rows[1].z;
	double coef11 = mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z;

	double coef12 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	double coef14 = mat.rows[1].x * mat.rows[3].w - mat.rows[3].x * mat.rows[1].w;
	double coef15 = mat.rows[1].x * mat.rows[2].w - mat.rows[2].x * mat.rows[1].w;

	double coef16 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	double coef18 = mat.rows[1].x * mat.rows[3].z - mat.rows[3].x * mat.rows[1].z;
	double coef19 = mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z;

	double coef20 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;
	double coef22 = mat.rows[1].x * mat.rows[3].y - mat.rows[3].x * mat.rows[1].y;
	double coef23 = mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y;

	double4 fac0 = { coef00, coef00, coef02, coef03 };
	double4 fac1 = { coef04, coef04, coef06, coef07 };
	double4 fac2 = { coef08, coef08, coef10, coef11 };
	double4 fac3 = { coef12, coef12, coef14, coef15 };
	double4 fac4 = { coef16, coef16, coef18, coef19 };
	double4 fac5 = { coef20, coef20, coef22, coef23 };

	double4 vec0 = { mat.rows[1].x, mat.rows[0].x, mat.rows[0].x, mat.rows[0].x };
	double4 vec1 = { mat.rows[1].y, mat.rows[0].y, mat.rows[0].y, mat.rows[0].y };
	double4 vec2 = { mat.rows[1].z, mat.rows[0].z, mat.rows[0].z, mat.rows[0].z };
	double4 vec3 = { mat.rows[1].w, mat.rows[0].w, mat.rows[0].w, mat.rows[0].w };

	double4 inv0 = vec1 * fac0 - vec2 * fac1 + vec3 * fac2;
	double4 inv1 = vec0 * fac0 - vec2 * fac3 + vec3 * fac4;
	double4 inv2 = vec0 * fac1 - vec1 * fac3 + vec3 * fac5;
	double4 inv3 = vec0 * fac2 - vec1 * fac4 + vec2 * fac5;

	double4 sign0 = double4(  1, -1,  1, -1 );
	double4 sign1 = double4( -1,  1, -1,  1 );

	double4x4 result = double4x4(
		inv0 * sign0,
		inv1 * sign1,
		inv2 * sign0,
		inv3 * sign1
	);

	double4 row0 = double4( result.rows[0][0], result.rows[1][0], result.rows[2][0], result.rows[3][0] );
	double4 dot0 = mat.rows[0] * row0;

	const double dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const double invdet = 1.0 / dot1;

	return result * invdet;
}

// Performs a matrix multiplication with 'lhs' and 'rhs' and returns the result.
HLML_INLINE double4x4 mul( const double4x4& lhs, const double4x4& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];
	double4 row3 = lhs.rows[3];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	double4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( double4x4 )
	{
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

// Multiplies the vector 'lhs' against the matrix 'rhs' and returns the result.
HLML_INLINE double4 mul( const double4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		( lhs.x * rhs.rows[0].x ) + ( lhs.y * rhs.rows[1].x ) + ( lhs.z * rhs.rows[2].x ) + ( lhs.w * rhs.rows[3].x ),
		( lhs.x * rhs.rows[0].y ) + ( lhs.y * rhs.rows[1].y ) + ( lhs.z * rhs.rows[2].y ) + ( lhs.w * rhs.rows[3].y ),
		( lhs.x * rhs.rows[0].z ) + ( lhs.y * rhs.rows[1].z ) + ( lhs.z * rhs.rows[2].z ) + ( lhs.w * rhs.rows[3].z ),
		( lhs.x * rhs.rows[0].w ) + ( lhs.y * rhs.rows[1].w ) + ( lhs.z * rhs.rows[2].w ) + ( lhs.w * rhs.rows[3].w )
	};
}

// "Translates" the matrix.  Adds the last column of 'mat' by the position vector 'vec'.
HLML_INLINE double4x4 translate( const double4x4& mat, const double3& vec )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

// Rotates the matrix by the given axis-angle (in radians) and returns the result.
HLML_INLINE double4x4 rotate( const double4x4& mat, const double rad, const double3& axis )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 u = normalized( axis );
	double ic = 1.0 - c;

	double4x4 rotation = mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return mul( mat, rotation );
}

// Applies a non-uniform scale to the matrix and returns the result.
HLML_INLINE double4x4 scale( const double4x4& mat, const double3& scale )
{
	return HLML_CONSTRUCT( double4x4 )
	{
		mat.rows[0].x * scale.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * scale.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * scale.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE double4x4 ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip space range: zero-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an left-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE double4x4 ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range 0 to 1.
HLML_INLINE double4x4 ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip space range: zero-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns an right-handed orthographic projection matrix with the clip-space range -1 to 1.
HLML_INLINE double4x4 ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 )
	{
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE double4x4 perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: zero-to-one
	const double far_minus_near = zfar - znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE double4x4 perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one-to-one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of 0 to 1.
HLML_INLINE double4x4 perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: zero-to-one
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0, 0.0, -1.0, 0.0
	};
}

// Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of -1 to 1.
HLML_INLINE double4x4 perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one-to-one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 )
	{
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, -far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, -1.0, 0.0
	};
}

// Returns a left-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE double4x4 look_at_lh( const double3& eye, const double3& target, const double3& up )
{
	// left handed
	const double3 forward = normalized( target - eye );
	const double3 up_cross_forward = cross( up, forward );
	const double3 right = normalized( up_cross_forward );
	const double3 up1 = cross( forward, right );

	return HLML_CONSTRUCT( double4x4 )
	{
		right.x,   right.y,   right.z,   -dot( right, eye ),
		up1.x,     up1.y,     up1.z,     -dot( up1, eye ),
		forward.x, forward.y, forward.z, -dot( forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

// Returns a right-handed orthonormal matrix that is oriented at position 'eye' to look at position 'target'.
HLML_INLINE double4x4 look_at_rh( const double3& eye, const double3& target, const double3& up )
{
	// right handed
	const double3 forward = normalized( target - eye );
	const double3 forward_cross_up = cross( forward, up );
	const double3 right = normalized( forward_cross_up );
	const double3 up1 = cross( right, forward );

	return HLML_CONSTRUCT( double4x4 )
	{
		 right.x,    right.y,    right.z,   -dot( right, eye ),
		 up1.x,      up1.y,      up1.z,     -dot( up1, eye ),
		-forward.x, -forward.y, -forward.z,  dot( forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

